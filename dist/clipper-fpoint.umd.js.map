{"version":3,"file":"clipper-fpoint.umd.js","sources":["../src/clipper_unminified.js"],"sourcesContent":["/*******************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.4.2                                                           *\n * Date      :  27 February 2017                                                *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2017                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.4.2.2 (FPoint)                                                *\n * Date      :  8 September 2017                                                *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n *                                                                              *\n *******************************************************************************/\n\n\tvar ClipperLib = {};\n\tClipperLib.version = '6.4.2.2';\n\n\t//UseLines: Enables open path clipping. Adds a very minor cost to performance.\n\tClipperLib.use_lines = true;\n\n\t//ClipperLib.use_xyz: adds a Z member to FPoint. Adds a minor cost to performance.\n\tClipperLib.use_xyz = false;\n\t// Here starts the actual Clipper library:\n\t// Helper function to support Inheritance in Javascript\n\tvar Inherit = function (ce, ce2)\n\t{\n\t\tvar p;\n\t\tif (typeof (Object.getOwnPropertyNames) === 'undefined')\n\t\t{\n\t\t\tfor (p in ce2.prototype)\n\t\t\t\tif (typeof (ce.prototype[p]) === 'undefined' || ce.prototype[p] === Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) === 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) === 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) === 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Path = function ()\n\t{\n\t\treturn [];\n\t};\n\n\tClipperLib.Path.prototype.push = Array.prototype.push;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Paths = function ()\n\t{\n\t\treturn []; // Was previously [[]], but caused problems when pushed\n\t};\n\n\tClipperLib.Paths.prototype.push = Array.prototype.push;\n\n\t// PolyTree & PolyNode start\n\t/**\n\t* @suppress {missingProperties}\n\t*/\n\tClipperLib.PolyNode = function ()\n\t{\n\t\tthis.m_Parent = null;\n\t\tthis.m_polygon = new ClipperLib.Path();\n\t\tthis.m_Index = 0;\n\t\tthis.m_jointype = 0;\n\t\tthis.m_endtype = 0;\n\t\tthis.m_Childs = [];\n\t\tthis.IsOpen = false;\n\t};\n\n\tClipperLib.PolyNode.prototype.IsHoleNode = function ()\n\t{\n\t\tvar result = true;\n\t\tvar node = this.m_Parent;\n\t\twhile (node !== null)\n\t\t{\n\t\t\tresult = !result;\n\t\t\tnode = node.m_Parent;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.PolyNode.prototype.ChildCount = function ()\n\t{\n\t\treturn this.m_Childs.length;\n\t};\n\n\tClipperLib.PolyNode.prototype.Contour = function ()\n\t{\n\t\treturn this.m_polygon;\n\t};\n\n\tClipperLib.PolyNode.prototype.AddChild = function (Child)\n\t{\n\t\tvar cnt = this.m_Childs.length;\n\t\tthis.m_Childs.push(Child);\n\t\tChild.m_Parent = this;\n\t\tChild.m_Index = cnt;\n\t};\n\n\tClipperLib.PolyNode.prototype.GetNext = function ()\n\t{\n\t\tif (this.m_Childs.length > 0)\n\t\t\treturn this.m_Childs[0];\n\t\telse\n\t\t\treturn this.GetNextSiblingUp();\n\t};\n\n\tClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n\t{\n\t\tif (this.m_Parent === null)\n\t\t\treturn null;\n\t\telse if (this.m_Index === this.m_Parent.m_Childs.length - 1)\n\t\t\treturn this.m_Parent.GetNextSiblingUp();\n\t\telse\n\t\t\treturn this.m_Parent.m_Childs[this.m_Index + 1];\n\t};\n\n\tClipperLib.PolyNode.prototype.Childs = function ()\n\t{\n\t\treturn this.m_Childs;\n\t};\n\n\tClipperLib.PolyNode.prototype.Parent = function ()\n\t{\n\t\treturn this.m_Parent;\n\t};\n\n\tClipperLib.PolyNode.prototype.IsHole = function ()\n\t{\n\t\treturn this.IsHoleNode();\n\t};\n\n\t// PolyTree : PolyNode\n\t/**\n\t * @suppress {missingProperties}\n\t * @constructor\n\t */\n\tClipperLib.PolyTree = function ()\n\t{\n\t\tthis.m_AllPolys = [];\n\t\tClipperLib.PolyNode.call(this);\n\t};\n\n\tClipperLib.PolyTree.prototype.Clear = function ()\n\t{\n\t\tfor (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n\t\t\tthis.m_AllPolys[i] = null;\n\t\tthis.m_AllPolys.length = 0;\n\t\tthis.m_Childs.length = 0;\n\t};\n\n\tClipperLib.PolyTree.prototype.GetFirst = function ()\n\t{\n\t\tif (this.m_Childs.length > 0)\n\t\t\treturn this.m_Childs[0];\n\t\telse\n\t\t\treturn null;\n\t};\n\n\tClipperLib.PolyTree.prototype.Total = function ()\n\t{\n\t\tvar result = this.m_AllPolys.length;\n\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\tif (result > 0 && this.m_Childs[0] !== this.m_AllPolys[0]) result--;\n\t\treturn result;\n\t};\n\n\tInherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n\n\t// PolyTree & PolyNode end\n\n\tClipperLib.Clear = function (a)\n\t{\n\t\ta.length = 0;\n\t};\n\n\t//ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n\tClipperLib.PI = 3.141592653589793;\n\tClipperLib.PI2 = 2 * 3.141592653589793;\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FPoint = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\talen = a.length;\n\t\tthis.X = 0;\n\t\tthis.Y = 0;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\tthis.Z = 0;\n\t\t\tif (alen === 3) // public FPoint(cInt x, cInt y, cInt z = 0)\n\t\t\t{\n\t\t\t\tthis.X = a[0];\n\t\t\t\tthis.Y = a[1];\n\t\t\t\tthis.Z = a[2];\n\t\t\t}\n\t\t\telse if (alen === 2) // public FPoint(cInt x, cInt y)\n\t\t\t{\n\t\t\t\tthis.X = a[0];\n\t\t\t\tthis.Y = a[1];\n\t\t\t\tthis.Z = 0;\n\t\t\t}\n\t\t\telse if (alen === 1)\n\t\t\t{\n\t\t\t\tif (a[0] instanceof ClipperLib.FPoint) // public FPoint(FPoint dp)\n\t\t\t\t{\n\t\t\t\t\tvar dp = a[0];\n\t\t\t\t\tthis.X = dp.X;\n\t\t\t\t\tthis.Y = dp.Y;\n\t\t\t\t\tthis.Z = 0;\n\t\t\t\t}\n\t\t\t\telse // public FPoint(FPoint pt)\n\t\t\t\t{\n\t\t\t\t\tvar pt = a[0];\n\t\t\t\t\tif (typeof (pt.Z) === \"undefined\") pt.Z = 0;\n\t\t\t\t\tthis.X = pt.X;\n\t\t\t\t\tthis.Y = pt.Y;\n\t\t\t\t\tthis.Z = pt.Z;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse // public FPoint()\n\t\t\t{\n\t\t\t\tthis.X = 0;\n\t\t\t\tthis.Y = 0;\n\t\t\t\tthis.Z = 0;\n\t\t\t}\n\t\t}\n\t\telse // if (!ClipperLib.use_xyz)\n\t\t{\n\t\t\tif (alen === 2) // public FPoint(cInt X, cInt Y)\n\t\t\t{\n\t\t\t\tthis.X = a[0];\n\t\t\t\tthis.Y = a[1];\n\t\t\t}\n\t\t\telse if (alen === 1)\n\t\t\t{\n\t\t\t\tif (a[0] instanceof ClipperLib.FPoint) // public FPoint(FPoint dp)\n\t\t\t\t{\n\t\t\t\t\tvar dp = a[0];\n\t\t\t\t\tthis.X = dp.X;\n\t\t\t\t\tthis.Y = dp.Y;\n\t\t\t\t}\n\t\t\t\telse // public FPoint(FPoint pt)\n\t\t\t\t{\n\t\t\t\t\tvar pt = a[0];\n\t\t\t\t\tthis.X = pt.X;\n\t\t\t\t\tthis.Y = pt.Y;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse // public FPoint(FPoint pt)\n\t\t\t{\n\t\t\t\tthis.X = 0;\n\t\t\t\tthis.Y = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.FPoint.op_Equality = function (a, b)\n\t{\n\t\t//return a == b;\n\t\treturn a.X === b.X && a.Y === b.Y;\n\t};\n\n\tClipperLib.FPoint.op_Inequality = function (a, b)\n\t{\n\t\t//return a !== b;\n\t\treturn a.X !== b.X || a.Y !== b.Y;\n\t};\n\n\t/*\n  ClipperLib.FPoint.prototype.Equals = function (obj)\n  {\n    if (obj === null)\n        return false;\n    if (obj instanceof ClipperLib.FPoint)\n    {\n        var a = Cast(obj, ClipperLib.FPoint);\n        return (this.X == a.X) && (this.Y == a.Y);\n    }\n    else\n        return false;\n  };\n\n\t*/\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FPoint0 = function ()\n\t{\n\t\tthis.X = 0;\n\t\tthis.Y = 0;\n\t\tif (ClipperLib.use_xyz)\n\t\t\tthis.Z = 0;\n\t};\n\n\tClipperLib.FPoint0.prototype = ClipperLib.FPoint.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FPoint1 = function (pt)\n\t{\n\t\tthis.X = pt.X;\n\t\tthis.Y = pt.Y;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\tif (typeof pt.Z === \"undefined\") this.Z = 0;\n\t\t\telse this.Z = pt.Z;\n\t\t}\n\t};\n\n\tClipperLib.FPoint1.prototype = ClipperLib.FPoint.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FPoint1dp = function (dp)\n\t{\n\t\tthis.X = dp.X;\n\t\tthis.Y = dp.Y;\n\t\tif (ClipperLib.use_xyz)\n\t\t\tthis.Z = 0;\n\t};\n\n\tClipperLib.FPoint1dp.prototype = ClipperLib.FPoint.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FPoint2 = function (x, y, z)\n\t{\n\t\tthis.X = x;\n\t\tthis.Y = y;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\tif (typeof z === \"undefined\") this.Z = 0;\n\t\t\telse this.Z = z;\n\t\t}\n\t};\n\n\tClipperLib.FPoint2.prototype = ClipperLib.FPoint.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FRect = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\talen = a.length;\n\t\tif (alen === 4) // function (l, t, r, b)\n\t\t{\n\t\t\tthis.left = a[0];\n\t\t\tthis.top = a[1];\n\t\t\tthis.right = a[2];\n\t\t\tthis.bottom = a[3];\n\t\t}\n\t\telse if (alen === 1) // function (ir)\n\t\t{\n\t\t\tvar ir = a[0];\n\t\t\tthis.left = ir.left;\n\t\t\tthis.top = ir.top;\n\t\t\tthis.right = ir.right;\n\t\t\tthis.bottom = ir.bottom;\n\t\t}\n\t\telse // function ()\n\t\t{\n\t\t\tthis.left = 0;\n\t\t\tthis.top = 0;\n\t\t\tthis.right = 0;\n\t\t\tthis.bottom = 0;\n\t\t}\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FRect0 = function ()\n\t{\n\t\tthis.left = 0;\n\t\tthis.top = 0;\n\t\tthis.right = 0;\n\t\tthis.bottom = 0;\n\t};\n\n\tClipperLib.FRect0.prototype = ClipperLib.FRect.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FRect1 = function (ir)\n\t{\n\t\tthis.left = ir.left;\n\t\tthis.top = ir.top;\n\t\tthis.right = ir.right;\n\t\tthis.bottom = ir.bottom;\n\t};\n\n\tClipperLib.FRect1.prototype = ClipperLib.FRect.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FRect4 = function (l, t, r, b)\n\t{\n\t\tthis.left = l;\n\t\tthis.top = t;\n\t\tthis.right = r;\n\t\tthis.bottom = b;\n\t};\n\n\tClipperLib.FRect4.prototype = ClipperLib.FRect.prototype;\n\n\tClipperLib.ClipType = {\n\t\tctIntersection: 0,\n\t\tctUnion: 1,\n\t\tctDifference: 2,\n\t\tctXor: 3\n\t};\n\n\tClipperLib.PolyType = {\n\t\tptSubject: 0,\n\t\tptClip: 1\n\t};\n\n\tClipperLib.PolyFillType = {\n\t\tpftEvenOdd: 0,\n\t\tpftNonZero: 1,\n\t\tpftPositive: 2,\n\t\tpftNegative: 3\n\t};\n\n\tClipperLib.JoinType = {\n\t\tjtSquare: 0,\n\t\tjtRound: 1,\n\t\tjtMiter: 2\n\t};\n\n\tClipperLib.EndType = {\n\t\tetOpenSquare: 0,\n\t\tetOpenRound: 1,\n\t\tetOpenButt: 2,\n\t\tetClosedLine: 3,\n\t\tetClosedPolygon: 4\n\t};\n\n\tClipperLib.EdgeSide = {\n\t\tesLeft: 0,\n\t\tesRight: 1\n\t};\n\n\tClipperLib.Direction = {\n\t\tdRightToLeft: 0,\n\t\tdLeftToRight: 1\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.TEdge = function ()\n\t{\n\t\tthis.Bot = new ClipperLib.FPoint0();\n\t\tthis.Curr = new ClipperLib.FPoint0(); //current (updated for every new scanbeam)\n\t\tthis.Top = new ClipperLib.FPoint0();\n\t\tthis.Delta = new ClipperLib.FPoint0();\n\t\tthis.Dx = 0;\n\t\tthis.PolyTyp = ClipperLib.PolyType.ptSubject;\n\t\tthis.Side = ClipperLib.EdgeSide.esLeft; //side only refers to current side of solution poly\n\t\tthis.WindDelta = 0; //1 or -1 depending on winding direction\n\t\tthis.WindCnt = 0;\n\t\tthis.WindCnt2 = 0; //winding count of the opposite polytype\n\t\tthis.OutIdx = 0;\n\t\tthis.Next = null;\n\t\tthis.Prev = null;\n\t\tthis.NextInLML = null;\n\t\tthis.NextInAEL = null;\n\t\tthis.PrevInAEL = null;\n\t\tthis.NextInSEL = null;\n\t\tthis.PrevInSEL = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.IntersectNode = function ()\n\t{\n\t\tthis.Edge1 = null;\n\t\tthis.Edge2 = null;\n\t\tthis.Pt = new ClipperLib.FPoint0();\n\t};\n\n\tClipperLib.MyIntersectNodeSort = function () {};\n\n\tClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n\t{\n\t\tvar i = node2.Pt.Y - node1.Pt.Y;\n\t\tif (i > 0) return 1;\n\t\telse if (i < 0) return -1;\n\t\telse return 0;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.LocalMinima = function ()\n\t{\n\t\tthis.Y = 0;\n\t\tthis.LeftBound = null;\n\t\tthis.RightBound = null;\n\t\tthis.Next = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Scanbeam = function ()\n\t{\n\t\tthis.Y = 0;\n\t\tthis.Next = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Maxima = function ()\n\t{\n\t\tthis.X = 0;\n\t\tthis.Next = null;\n\t\tthis.Prev = null;\n\t};\n\n\t//OutRec: contains a path in the clipping solution. Edges in the AEL will\n\t//carry a pointer to an OutRec when they are part of the clipping solution.\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.OutRec = function ()\n\t{\n\t\tthis.Idx = 0;\n\t\tthis.IsHole = false;\n\t\tthis.IsOpen = false;\n\t\tthis.FirstLeft = null; //see comments in clipper.pas\n\t\tthis.Pts = null;\n\t\tthis.BottomPt = null;\n\t\tthis.PolyNode = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.OutPt = function ()\n\t{\n\t\tthis.Idx = 0;\n\t\tthis.Pt = new ClipperLib.FPoint0();\n\t\tthis.Next = null;\n\t\tthis.Prev = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Join = function ()\n\t{\n\t\tthis.OutPt1 = null;\n\t\tthis.OutPt2 = null;\n\t\tthis.OffPt = new ClipperLib.FPoint0();\n\t};\n\n\tClipperLib.ClipperBase = function ()\n\t{\n\t\tthis.m_MinimaList = null;\n\t\tthis.m_CurrentLM = null;\n\t\tthis.m_edges = new Array();\n\t\tthis.m_HasOpenPaths = false;\n\t\tthis.PreserveCollinear = false;\n\t\tthis.m_Scanbeam = null;\n\t\tthis.m_PolyOuts = null;\n\t\tthis.m_ActiveEdges = null;\n\t};\n\n\tClipperLib.ClipperBase.horizontal = -3.4E+38;\n\tClipperLib.ClipperBase.Skip = -2;\n\tClipperLib.ClipperBase.Unassigned = -1;\n\tClipperLib.ClipperBase.tolerance = 1E-20;\n\n\t// The MAX_VALUE property has a value of 1.7976931348623157e+308. Values larger than MAX_VALUE are represented as \"Infinity\".\n\t//MIN_VALUE has a value of 5e-324. Values smaller than MIN_VALUE (\"underflow values\") are converted to 0.\n\tClipperLib.ClipperBase.maxValue = Math.sqrt(Number.MAX_VALUE); // 1.3407807929942596e+154\n\tClipperLib.ClipperBase.minValue = Math.sqrt(Number.MIN_VALUE); // 2.2227587494850775e-162\n\n\tClipperLib.ClipperBase.near_zero = function (val)\n\t{\n\t\treturn (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n\t};\n\n\tClipperLib.ClipperBase.IsHorizontal = function (e)\n\t{\n\t\treturn e.Delta.Y === 0;\n\t};\n\n\tClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n\t{\n\t\tvar pp2 = pp;\n\t\tdo {\n\t\t\tif (ClipperLib.FPoint.op_Equality(pp2.Pt, pt))\n\t\t\t\treturn true;\n\t\t\tpp2 = pp2.Next;\n\t\t}\n\t\twhile (pp2 !== pp)\n\t\treturn false;\n\t};\n\n\tClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2)\n\t{\n\t\t\treturn ((pt.X === linePt1.X) && (pt.Y === linePt1.Y)) || ((pt.X === linePt2.X) && (pt.Y === linePt2.Y)) || (((pt.X > linePt1.X) === (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) === (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) === (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n\t};\n\n\tClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp)\n\t{\n\t\tvar pp2 = pp;\n\t\twhile (true)\n\t\t{\n\t\t\tif (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt))\n\t\t\t\treturn true;\n\t\t\tpp2 = pp2.Next;\n\t\t\tif (pp2 === pp)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t};\n\n\tClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\talen = a.length;\n\t\tvar e1, e2, pt1, pt2, pt3, pt4;\n\t\tif (alen === 2) // function (e1, e2)\n\t\t{\n\t\t\te1 = a[0];\n\t\t\te2 = a[1];\n\t\t\treturn e1.Delta.Y * e2.Delta.X === e1.Delta.X * e2.Delta.Y;\n\t\t}\n\t\telse if (alen === 3) // function (pt1, pt2, pt3)\n\t\t{\n\t\t\tpt1 = a[0];\n\t\t\tpt2 = a[1];\n\t\t\tpt3 = a[2];\n\t\t\treturn (pt1.Y - pt2.Y) * (pt2.X - pt3.X) - (pt1.X - pt2.X) * (pt2.Y - pt3.Y) === 0;\n\t\t}\n\t\telse // function (pt1, pt2, pt3, pt4)\n\t\t{\n\t\t\tpt1 = a[0];\n\t\t\tpt2 = a[1];\n\t\t\tpt3 = a[2];\n\t\t\tpt4 = a[3];\n\t\t\treturn (pt1.Y - pt2.Y) * (pt3.X - pt4.X) - (pt1.X - pt2.X) * (pt3.Y - pt4.Y) === 0;\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2)\n\t{\n\t\treturn e1.Delta.Y * e2.Delta.X === e1.Delta.X * e2.Delta.Y;\n\t};\n\n\tClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3)\n\t{\n\t\treturn (pt1.Y - pt2.Y) * (pt2.X - pt3.X) - (pt1.X - pt2.X) * (pt2.Y - pt3.Y) === 0;\n\t};\n\n\tClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4)\n\t{\n\t\treturn (pt1.Y - pt2.Y) * (pt3.X - pt4.X) - (pt1.X - pt2.X) * (pt3.Y - pt4.Y) === 0;\n\t};\n\n\tClipperLib.ClipperBase.prototype.Clear = function ()\n\t{\n\t\tthis.DisposeLocalMinimaList();\n\t\tfor (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n\t\t{\n\t\t\tfor (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n\t\t\t\tthis.m_edges[i][j] = null;\n\t\t\tClipperLib.Clear(this.m_edges[i]);\n\t\t}\n\t\tClipperLib.Clear(this.m_edges);\n\t\tthis.m_HasOpenPaths = false;\n\t};\n\n\tClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n\t{\n\t\twhile (this.m_MinimaList !== null)\n\t\t{\n\t\t\tvar tmpLm = this.m_MinimaList.Next;\n\t\t\tthis.m_MinimaList = null;\n\t\t\tthis.m_MinimaList = tmpLm;\n\t\t}\n\t\tthis.m_CurrentLM = null;\n\t};\n\n\tClipperLib.ClipperBase.prototype.RangeTest = function (pt)\n\t{\n\t\tif(pt.X > ClipperLib.ClipperBase.maxValue || pt.X < -ClipperLib.ClipperBase.maxValue\n\t\t|| pt.Y > ClipperLib.ClipperBase.maxValue || pt.Y < -ClipperLib.ClipperBase.maxValue\n|| (pt.X > 0 && pt.X < ClipperLib.ClipperBase.minValue)\n|| (pt.Y > 0 && pt.Y < ClipperLib.ClipperBase.minValue)\n|| (pt.X < 0 && pt.X > -ClipperLib.ClipperBase.minValue)\n|| (pt.Y < 0 && pt.Y > -ClipperLib.ClipperBase.minValue))\n\t\t\tClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n\t};\n\n\tClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n\t{\n\t\te.Next = eNext;\n\t\te.Prev = ePrev;\n\t\t//e.Curr = pt;\n\t\te.Curr.X = pt.X;\n\t\te.Curr.Y = pt.Y;\n\t\tif (ClipperLib.use_xyz) e.Curr.Z = pt.Z;\n\t\te.OutIdx = -1;\n\t};\n\n\tClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n\t{\n\t\tif (e.Curr.Y >= e.Next.Curr.Y)\n\t\t{\n\t\t\t//e.Bot = e.Curr;\n\t\t\te.Bot.X = e.Curr.X;\n\t\t\te.Bot.Y = e.Curr.Y;\n\t\t\tif (ClipperLib.use_xyz) e.Bot.Z = e.Curr.Z;\n\t\t\t//e.Top = e.Next.Curr;\n\t\t\te.Top.X = e.Next.Curr.X;\n\t\t\te.Top.Y = e.Next.Curr.Y;\n\t\t\tif (ClipperLib.use_xyz) e.Top.Z = e.Next.Curr.Z;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//e.Top = e.Curr;\n\t\t\te.Top.X = e.Curr.X;\n\t\t\te.Top.Y = e.Curr.Y;\n\t\t\tif (ClipperLib.use_xyz) e.Top.Z = e.Curr.Z;\n\t\t\t//e.Bot = e.Next.Curr;\n\t\t\te.Bot.X = e.Next.Curr.X;\n\t\t\te.Bot.Y = e.Next.Curr.Y;\n\t\t\tif (ClipperLib.use_xyz) e.Bot.Z = e.Next.Curr.Z;\n\t\t}\n\t\tthis.SetDx(e);\n\t\te.PolyTyp = polyType;\n\t};\n\n\tClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n\t{\n\t\tvar E2;\n\t\tfor (;;)\n\t\t{\n\t\t\twhile (ClipperLib.FPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.FPoint.op_Equality(E.Curr, E.Top))\n\t\t\t\tE = E.Next;\n\t\t\tif (E.Dx !== ClipperLib.ClipperBase.horizontal && E.Prev.Dx !== ClipperLib.ClipperBase.horizontal)\n\t\t\t\tbreak;\n\t\t\twhile (E.Prev.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t\t\tE = E.Prev;\n\t\t\tE2 = E;\n\t\t\twhile (E.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t\t\tE = E.Next;\n\t\t\tif (E.Top.Y === E.Prev.Bot.Y)\n\t\t\t\tcontinue;\n\t\t\t//ie just an intermediate horz.\n\t\t\tif (E2.Prev.Bot.X < E.Bot.X)\n\t\t\t\tE = E2;\n\t\t\tbreak;\n\t\t}\n\t\treturn E;\n\t};\n\n\tClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n\t{\n\t\tvar EStart;\n\t\tvar Result = E;\n\t\tvar Horz;\n\n\t\tif (Result.OutIdx === ClipperLib.ClipperBase.Skip)\n\t\t{\n\t\t\t//check if there are edges beyond the skip edge in the bound and if so\n\t\t\t//create another LocMin and calling ProcessBound once more ...\n\t\t\tE = Result;\n\t\t\tif (LeftBoundIsForward)\n\t\t\t{\n\t\t\t\twhile (E.Top.Y === E.Next.Bot.Y) E = E.Next;\n\t\t\t\twhile (E !== Result && E.Dx === ClipperLib.ClipperBase.horizontal) E = E.Prev;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (E.Top.Y === E.Prev.Bot.Y) E = E.Prev;\n\t\t\t\twhile (E !== Result && E.Dx === ClipperLib.ClipperBase.horizontal) E = E.Next;\n\t\t\t}\n\t\t\tif (E === Result)\n\t\t\t{\n\t\t\t\tif (LeftBoundIsForward) Result = E.Next;\n\t\t\t\telse Result = E.Prev;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//there are more edges in the bound beyond result starting with E\n\t\t\t\tif (LeftBoundIsForward)\n\t\t\t\t\tE = Result.Next;\n\t\t\t\telse\n\t\t\t\t\tE = Result.Prev;\n\t\t\t\tvar locMin = new ClipperLib.LocalMinima();\n\t\t\t\tlocMin.Next = null;\n\t\t\t\tlocMin.Y = E.Bot.Y;\n\t\t\t\tlocMin.LeftBound = null;\n\t\t\t\tlocMin.RightBound = E;\n\t\t\t\tE.WindDelta = 0;\n\t\t\t\tResult = this.ProcessBound(E, LeftBoundIsForward);\n\t\t\t\tthis.InsertLocalMinima(locMin);\n\t\t\t}\n\t\t\treturn Result;\n\t\t}\n\n\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t{\n\t\t\t//We need to be careful with open paths because this may not be a\n\t\t\t//true local minima (ie E may be following a skip edge).\n\t\t\t//Also, consecutive horz. edges may start heading left before going right.\n\t\t\tif (LeftBoundIsForward) EStart = E.Prev;\n\t\t\telse EStart = E.Next;\n\n\t\t\tif (EStart.Dx === ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n\t\t\t{\n\t\t\t\tif (EStart.Bot.X !== E.Bot.X && EStart.Top.X !== E.Bot.X)\n\t\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\t}\n\t\t\telse if (EStart.Bot.X !== E.Bot.X)\n\t\t\t\tthis.ReverseHorizontal(E);\n\t\t}\n\n\t\tEStart = E;\n\t\tif (LeftBoundIsForward)\n\t\t{\n\t\t\twhile (Result.Top.Y === Result.Next.Bot.Y && Result.Next.OutIdx !== ClipperLib.ClipperBase.Skip)\n\t\t\t\tResult = Result.Next;\n\t\t\tif (Result.Dx === ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx !== ClipperLib.ClipperBase.Skip)\n\t\t\t{\n\t\t\t\t//nb: at the top of a bound, horizontals are added to the bound\n\t\t\t\t//only when the preceding edge attaches to the horizontal's left vertex\n\t\t\t\t//unless a Skip edge is encountered when that becomes the top divide\n\t\t\t\tHorz = Result;\n\t\t\t\twhile (Horz.Prev.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t\t\t\tHorz = Horz.Prev;\n\t\t\t\tif (Horz.Prev.Top.X > Result.Next.Top.X)\n\t\t\t\t\tResult = Horz.Prev;\n\t\t\t}\n\t\t\twhile (E !== Result)\n\t\t\t{\n\t\t\t\tE.NextInLML = E.Next;\n\t\t\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Prev.Top.X)\n\t\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\t\tE = E.Next;\n\t\t\t}\n\t\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Prev.Top.X)\n\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\tResult = Result.Next;\n\t\t\t//move to the edge just beyond current bound\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (Result.Top.Y === Result.Prev.Bot.Y && Result.Prev.OutIdx !== ClipperLib.ClipperBase.Skip)\n\t\t\t\tResult = Result.Prev;\n\t\t\tif (Result.Dx === ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx !== ClipperLib.ClipperBase.Skip)\n\t\t\t{\n\t\t\t\tHorz = Result;\n\t\t\t\twhile (Horz.Next.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t\t\t\tHorz = Horz.Next;\n\t\t\t\tif (Horz.Next.Top.X === Result.Prev.Top.X || Horz.Next.Top.X > Result.Prev.Top.X)\n\t\t\t\t{\n\t\t\t\t\tResult = Horz.Next;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (E !== Result)\n\t\t\t{\n\t\t\t\tE.NextInLML = E.Prev;\n\t\t\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Next.Top.X)\n\t\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\t\tE = E.Prev;\n\t\t\t}\n\t\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Next.Top.X)\n\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\tResult = Result.Prev;\n\t\t\t//move to the edge just beyond current bound\n\t\t}\n\n\t\treturn Result;\n\t};\n\n\tClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n\t{\n\t\tif (ClipperLib.use_lines)\n\t\t{\n\t\t\tif (!Closed && polyType === ClipperLib.PolyType.ptClip)\n\t\t\t\tClipperLib.Error(\"AddPath: Open paths must be subject.\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!Closed)\n\t\t\t\tClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n\t\t}\n\t\tvar highI = pg.length - 1;\n\t\tif (Closed)\n\t\t\twhile (highI > 0 && (ClipperLib.FPoint.op_Equality(pg[highI], pg[0])))\n\t\t\t\t--highI;\n\t\twhile (highI > 0 && (ClipperLib.FPoint.op_Equality(pg[highI], pg[highI - 1])))\n\t\t\t--highI;\n\t\tif ((Closed && highI < 2) || (!Closed && highI < 1))\n\t\t\treturn false;\n\t\t//create a new edge array ...\n\t\tvar edges = new Array();\n\t\tfor (var i = 0; i <= highI; i++)\n\t\t\tedges.push(new ClipperLib.TEdge());\n\t\tvar IsFlat = true;\n\t\t//1. Basic (first) edge initialization ...\n\n\t\t//edges[1].Curr = pg[1];\n\t\tedges[1].Curr.X = pg[1].X;\n\t\tedges[1].Curr.Y = pg[1].Y;\n\t\tif (ClipperLib.use_xyz) edges[1].Curr.Z = pg[1].Z;\n\n\t\tthis.RangeTest(pg[0]);\n\n\t\tthis.RangeTest(pg[highI]);\n\n\t\tthis.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n\t\tthis.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n\t\tfor (var i = highI - 1; i >= 1; --i)\n\t\t{\n\t\t\tthis.RangeTest(pg[i]);\n\n\t\t\tthis.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n\t\t}\n\n\t\tvar eStart = edges[0];\n\t\t//2. Remove duplicate vertices, and (when closed) collinear edges ...\n\t\tvar E = eStart,\n\t\t\teLoopStop = eStart;\n\t\tfor (;;)\n\t\t{\n\t\t\t//console.log(E.Next, eStart);\n\t\t\t//nb: allows matching start and end points when not Closed ...\n\t\t\tif (E.Curr === E.Next.Curr && (Closed || E.Next !== eStart))\n\t\t\t{\n\t\t\t\tif (E === E.Next)\n\t\t\t\t\tbreak;\n\t\t\t\tif (E === eStart)\n\t\t\t\t\teStart = E.Next;\n\t\t\t\tE = this.RemoveEdge(E);\n\t\t\t\teLoopStop = E;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (E.Prev === E.Next)\n\t\t\t\tbreak;\n\t\t\telse if (Closed && ClipperLib.ClipperBase.SlopesEqual4(E.Prev.Curr, E.Curr, E.Next.Curr) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n\t\t\t{\n\t\t\t\t//Collinear edges are allowed for open paths but in closed paths\n\t\t\t\t//the default is to merge adjacent collinear edges into a single edge.\n\t\t\t\t//However, if the PreserveCollinear property is enabled, only overlapping\n\t\t\t\t//collinear edges (ie spikes) will be removed from closed paths.\n\t\t\t\tif (E === eStart)\n\t\t\t\t\teStart = E.Next;\n\t\t\t\tE = this.RemoveEdge(E);\n\t\t\t\tE = E.Prev;\n\t\t\t\teLoopStop = E;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tE = E.Next;\n\t\t\tif ((E === eLoopStop) || (!Closed && E.Next === eStart)) break;\n\t\t}\n\t\tif ((!Closed && (E === E.Next)) || (Closed && (E.Prev === E.Next)))\n\t\t\treturn false;\n\t\tif (!Closed)\n\t\t{\n\t\t\tthis.m_HasOpenPaths = true;\n\t\t\teStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t\t}\n\t\t//3. Do second stage of edge initialization ...\n\t\tE = eStart;\n\t\tdo {\n\t\t\tthis.InitEdge2(E, polyType);\n\t\t\tE = E.Next;\n\t\t\tif (IsFlat && E.Curr.Y !== eStart.Curr.Y)\n\t\t\t\tIsFlat = false;\n\t\t}\n\t\twhile (E !== eStart)\n\t\t//4. Finally, add edge bounds to LocalMinima list ...\n\t\t//Totally flat paths must be handled differently when adding them\n\t\t//to LocalMinima list to avoid endless loops etc ...\n\t\tif (IsFlat)\n\t\t{\n\t\t\tif (Closed)\n\t\t\t\treturn false;\n\n\t\t\tE.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\n\t\t\tvar locMin = new ClipperLib.LocalMinima();\n\t\t\tlocMin.Next = null;\n\t\t\tlocMin.Y = E.Bot.Y;\n\t\t\tlocMin.LeftBound = null;\n\t\t\tlocMin.RightBound = E;\n\t\t\tlocMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t\t\tlocMin.RightBound.WindDelta = 0;\n\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tif (E.Bot.X !== E.Prev.Top.X) this.ReverseHorizontal(E);\n\t\t\t\tif (E.Next.OutIdx === ClipperLib.ClipperBase.Skip) break;\n\t\t\t\tE.NextInLML = E.Next;\n\t\t\t\tE = E.Next;\n\t\t\t}\n\t\t\tthis.InsertLocalMinima(locMin);\n\t\t\tthis.m_edges.push(edges);\n\t\t\treturn true;\n\t\t}\n\t\tthis.m_edges.push(edges);\n\t\tvar leftBoundIsForward;\n\t\tvar EMin = null;\n\n\t\t//workaround to avoid an endless loop in the while loop below when\n\t\t//open paths have matching start and end points ...\n\t\tif (ClipperLib.FPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n\t\t\tE = E.Next;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tE = this.FindNextLocMin(E);\n\t\t\tif (E === EMin)\n\t\t\t\tbreak;\n\t\t\telse if (EMin === null)\n\t\t\t\tEMin = E;\n\t\t\t//E and E.Prev now share a local minima (left aligned if horizontal).\n\t\t\t//Compare their slopes to find which starts which bound ...\n\t\t\tvar locMin = new ClipperLib.LocalMinima();\n\t\t\tlocMin.Next = null;\n\t\t\tlocMin.Y = E.Bot.Y;\n\t\t\tif (E.Dx < E.Prev.Dx)\n\t\t\t{\n\t\t\t\tlocMin.LeftBound = E.Prev;\n\t\t\t\tlocMin.RightBound = E;\n\t\t\t\tleftBoundIsForward = false;\n\t\t\t\t//Q.nextInLML = Q.prev\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlocMin.LeftBound = E;\n\t\t\t\tlocMin.RightBound = E.Prev;\n\t\t\t\tleftBoundIsForward = true;\n\t\t\t\t//Q.nextInLML = Q.next\n\t\t\t}\n\t\t\tlocMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n\t\t\tlocMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t\t\tif (!Closed)\n\t\t\t\tlocMin.LeftBound.WindDelta = 0;\n\t\t\telse if (locMin.LeftBound.Next === locMin.RightBound)\n\t\t\t\tlocMin.LeftBound.WindDelta = -1;\n\t\t\telse\n\t\t\t\tlocMin.LeftBound.WindDelta = 1;\n\t\t\tlocMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n\t\t\tE = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n\t\t\tif (E.OutIdx === ClipperLib.ClipperBase.Skip)\n\t\t\t\tE = this.ProcessBound(E, leftBoundIsForward);\n\t\t\tvar E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n\t\t\tif (E2.OutIdx === ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n\t\t\tif (locMin.LeftBound.OutIdx === ClipperLib.ClipperBase.Skip)\n\t\t\t\tlocMin.LeftBound = null;\n\t\t\telse if (locMin.RightBound.OutIdx === ClipperLib.ClipperBase.Skip)\n\t\t\t\tlocMin.RightBound = null;\n\t\t\tthis.InsertLocalMinima(locMin);\n\t\t\tif (!leftBoundIsForward)\n\t\t\t\tE = E2;\n\t\t}\n\t\treturn true;\n\t};\n\n\tClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n\t{\n\t\t//  console.log(\"-------------------------------------------\");\n\t\t//  console.log(JSON.stringify(ppg));\n\t\tvar result = false;\n\t\tfor (var i = 0, ilen = ppg.length; i < ilen; ++i)\n\t\t\tif (this.AddPath(ppg[i], polyType, closed))\n\t\t\t\tresult = true;\n\t\treturn result;\n\t};\n\n\tClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n\t{\n\t\tif ((ClipperLib.FPoint.op_Equality(pt1, pt3)) || (ClipperLib.FPoint.op_Equality(pt1, pt2)) || (ClipperLib.FPoint.op_Equality(pt3, pt2)))\n\n\t\t\t//if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n\t\t\treturn false;\n\n\t\telse if (pt1.X !== pt3.X)\n\t\t\treturn (pt2.X > pt1.X) === (pt2.X < pt3.X);\n\t\telse\n\t\t\treturn (pt2.Y > pt1.Y) === (pt2.Y < pt3.Y);\n\t};\n\n\tClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n\t{\n\t\t//removes e from double_linked_list (but without removing from memory)\n\t\te.Prev.Next = e.Next;\n\t\te.Next.Prev = e.Prev;\n\t\tvar result = e.Next;\n\t\te.Prev = null; //flag as removed (see ClipperBase.Clear)\n\t\treturn result;\n\t};\n\n\tClipperLib.ClipperBase.prototype.SetDx = function (e)\n\t{\n\t\te.Delta.X = (e.Top.X - e.Bot.X);\n\t\te.Delta.Y = (e.Top.Y - e.Bot.Y);\n\t\tif (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n\t\telse e.Dx = (e.Delta.X) / (e.Delta.Y);\n\t};\n\n\tClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n\t{\n\t\tif (this.m_MinimaList === null)\n\t\t{\n\t\t\tthis.m_MinimaList = newLm;\n\t\t}\n\t\telse if (newLm.Y >= this.m_MinimaList.Y)\n\t\t{\n\t\t\tnewLm.Next = this.m_MinimaList;\n\t\t\tthis.m_MinimaList = newLm;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmpLm = this.m_MinimaList;\n\t\t\twhile (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n\t\t\t\ttmpLm = tmpLm.Next;\n\t\t\tnewLm.Next = tmpLm.Next;\n\t\t\ttmpLm.Next = newLm;\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.prototype.PopLocalMinima = function (Y, current)\n\t{\n\t\tcurrent.v = this.m_CurrentLM;\n\t\tif (this.m_CurrentLM !== null && this.m_CurrentLM.Y === Y)\n\t\t{\n\t\t\tthis.m_CurrentLM = this.m_CurrentLM.Next;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n\t{\n\t\t//swap horizontal edges' top and bottom x's so they follow the natural\n\t\t//progression of the bounds - ie so their xbots will align with the\n\t\t//adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n\t\tvar tmp = e.Top.X;\n\t\te.Top.X = e.Bot.X;\n\t\te.Bot.X = tmp;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\ttmp = e.Top.Z;\n\t\t\te.Top.Z = e.Bot.Z;\n\t\t\te.Bot.Z = tmp;\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.prototype.Reset = function ()\n\t{\n\t\tthis.m_CurrentLM = this.m_MinimaList;\n\t\tif (this.m_CurrentLM === null) //ie nothing to process\n\t\t\treturn;\n\t\t//reset all edges ...\n\t\tthis.m_Scanbeam = null;\n\t\tvar lm = this.m_MinimaList;\n\t\twhile (lm !== null)\n\t\t{\n\t\t\tthis.InsertScanbeam(lm.Y);\n\t\t\tvar e = lm.LeftBound;\n\t\t\tif (e !== null)\n\t\t\t{\n\t\t\t\t//e.Curr = e.Bot;\n\t\t\t\te.Curr.X = e.Bot.X;\n\t\t\t\te.Curr.Y = e.Bot.Y;\n\t\t\t\tif (ClipperLib.use_xyz) e.Curr.Z = e.Bot.Z;\n\t\t\t\te.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t\t\t}\n\t\t\te = lm.RightBound;\n\t\t\tif (e !== null)\n\t\t\t{\n\t\t\t\t//e.Curr = e.Bot;\n\t\t\t\te.Curr.X = e.Bot.X;\n\t\t\t\te.Curr.Y = e.Bot.Y;\n\t\t\t\tif (ClipperLib.use_xyz) e.Curr.Z = e.Bot.Z;\n\t\t\t\te.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t\t\t}\n\t\t\tlm = lm.Next;\n\t\t}\n\t\tthis.m_ActiveEdges = null;\n\t};\n\n\tClipperLib.ClipperBase.prototype.InsertScanbeam = function (Y)\n\t{\n\t\t//single-linked list: sorted descending, ignoring dups.\n\t\tif (this.m_Scanbeam === null)\n\t\t{\n\t\t\tthis.m_Scanbeam = new ClipperLib.Scanbeam();\n\t\t\tthis.m_Scanbeam.Next = null;\n\t\t\tthis.m_Scanbeam.Y = Y;\n\t\t}\n\t\telse if (Y > this.m_Scanbeam.Y)\n\t\t{\n\t\t\tvar newSb = new ClipperLib.Scanbeam();\n\t\t\tnewSb.Y = Y;\n\t\t\tnewSb.Next = this.m_Scanbeam;\n\t\t\tthis.m_Scanbeam = newSb;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar sb2 = this.m_Scanbeam;\n\t\t\twhile (sb2.Next !== null && Y <= sb2.Next.Y)\n\t\t\t{\n\t\t\t\tsb2 = sb2.Next;\n\t\t\t}\n\t\t\tif (Y === sb2.Y)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t} //ie ignores duplicates\n\t\t\tvar newSb1 = new ClipperLib.Scanbeam();\n\t\t\tnewSb1.Y = Y;\n\t\t\tnewSb1.Next = sb2.Next;\n\t\t\tsb2.Next = newSb1;\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.prototype.PopScanbeam = function (Y)\n\t{\n\t\tif (this.m_Scanbeam === null)\n\t\t{\n\t\t\tY.v = 0;\n\t\t\treturn false;\n\t\t}\n\t\tY.v = this.m_Scanbeam.Y;\n\t\tthis.m_Scanbeam = this.m_Scanbeam.Next;\n\t\treturn true;\n\t};\n\n\tClipperLib.ClipperBase.prototype.LocalMinimaPending = function ()\n\t{\n\t\treturn (this.m_CurrentLM !== null);\n\t};\n\n\tClipperLib.ClipperBase.prototype.CreateOutRec = function ()\n\t{\n\t\tvar result = new ClipperLib.OutRec();\n\t\tresult.Idx = ClipperLib.ClipperBase.Unassigned;\n\t\tresult.IsHole = false;\n\t\tresult.IsOpen = false;\n\t\tresult.FirstLeft = null;\n\t\tresult.Pts = null;\n\t\tresult.BottomPt = null;\n\t\tresult.PolyNode = null;\n\t\tthis.m_PolyOuts.push(result);\n\t\tresult.Idx = this.m_PolyOuts.length - 1;\n\t\treturn result;\n\t};\n\n\tClipperLib.ClipperBase.prototype.DisposeOutRec = function (index)\n\t{\n\t\tvar outRec = this.m_PolyOuts[index];\n\t\toutRec.Pts = null;\n\t\toutRec = null;\n\t\tthis.m_PolyOuts[index] = null;\n\t};\n\n\tClipperLib.ClipperBase.prototype.UpdateEdgeIntoAEL = function (e)\n\t{\n\t\tif (e.NextInLML === null)\n\t\t{\n\t\t\tClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n\t\t}\n\t\tvar AelPrev = e.PrevInAEL;\n\t\tvar AelNext = e.NextInAEL;\n\t\te.NextInLML.OutIdx = e.OutIdx;\n\t\tif (AelPrev !== null)\n\t\t{\n\t\t\tAelPrev.NextInAEL = e.NextInLML;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.m_ActiveEdges = e.NextInLML;\n\t\t}\n\t\tif (AelNext !== null)\n\t\t{\n\t\t\tAelNext.PrevInAEL = e.NextInLML;\n\t\t}\n\t\te.NextInLML.Side = e.Side;\n\t\te.NextInLML.WindDelta = e.WindDelta;\n\t\te.NextInLML.WindCnt = e.WindCnt;\n\t\te.NextInLML.WindCnt2 = e.WindCnt2;\n\t\te = e.NextInLML;\n\t\te.Curr.X = e.Bot.X;\n\t\te.Curr.Y = e.Bot.Y;\n\t\te.PrevInAEL = AelPrev;\n\t\te.NextInAEL = AelNext;\n\t\tif (!ClipperLib.ClipperBase.IsHorizontal(e))\n\t\t{\n\t\t\tthis.InsertScanbeam(e.Top.Y);\n\t\t}\n\t\treturn e;\n\t};\n\n\tClipperLib.ClipperBase.prototype.SwapPositionsInAEL = function (edge1, edge2)\n\t{\n\t\t//check that one or other edge hasn't already been removed from AEL ...\n\t\tif (edge1.NextInAEL === edge1.PrevInAEL || edge2.NextInAEL === edge2.PrevInAEL)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (edge1.NextInAEL === edge2)\n\t\t{\n\t\t\tvar next = edge2.NextInAEL;\n\t\t\tif (next !== null)\n\t\t\t{\n\t\t\t\tnext.PrevInAEL = edge1;\n\t\t\t}\n\t\t\tvar prev = edge1.PrevInAEL;\n\t\t\tif (prev !== null)\n\t\t\t{\n\t\t\t\tprev.NextInAEL = edge2;\n\t\t\t}\n\t\t\tedge2.PrevInAEL = prev;\n\t\t\tedge2.NextInAEL = edge1;\n\t\t\tedge1.PrevInAEL = edge2;\n\t\t\tedge1.NextInAEL = next;\n\t\t}\n\t\telse if (edge2.NextInAEL === edge1)\n\t\t{\n\t\t\tvar next1 = edge1.NextInAEL;\n\t\t\tif (next1 !== null)\n\t\t\t{\n\t\t\t\tnext1.PrevInAEL = edge2;\n\t\t\t}\n\t\t\tvar prev1 = edge2.PrevInAEL;\n\t\t\tif (prev1 !== null)\n\t\t\t{\n\t\t\t\tprev1.NextInAEL = edge1;\n\t\t\t}\n\t\t\tedge1.PrevInAEL = prev1;\n\t\t\tedge1.NextInAEL = edge2;\n\t\t\tedge2.PrevInAEL = edge1;\n\t\t\tedge2.NextInAEL = next1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar next2 = edge1.NextInAEL;\n\t\t\tvar prev2 = edge1.PrevInAEL;\n\t\t\tedge1.NextInAEL = edge2.NextInAEL;\n\t\t\tif (edge1.NextInAEL !== null)\n\t\t\t{\n\t\t\t\tedge1.NextInAEL.PrevInAEL = edge1;\n\t\t\t}\n\t\t\tedge1.PrevInAEL = edge2.PrevInAEL;\n\t\t\tif (edge1.PrevInAEL !== null)\n\t\t\t{\n\t\t\t\tedge1.PrevInAEL.NextInAEL = edge1;\n\t\t\t}\n\t\t\tedge2.NextInAEL = next2;\n\t\t\tif (edge2.NextInAEL !== null)\n\t\t\t{\n\t\t\t\tedge2.NextInAEL.PrevInAEL = edge2;\n\t\t\t}\n\t\t\tedge2.PrevInAEL = prev2;\n\t\t\tif (edge2.PrevInAEL !== null)\n\t\t\t{\n\t\t\t\tedge2.PrevInAEL.NextInAEL = edge2;\n\t\t\t}\n\t\t}\n\n\t\tif (edge1.PrevInAEL === null)\n\t\t{\n\t\t\tthis.m_ActiveEdges = edge1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (edge2.PrevInAEL === null)\n\t\t\t{\n\t\t\t\tthis.m_ActiveEdges = edge2;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.prototype.DeleteFromAEL = function (e)\n\t{\n\t\tvar AelPrev = e.PrevInAEL;\n\t\tvar AelNext = e.NextInAEL;\n\t\tif (AelPrev === null && AelNext === null && e !== this.m_ActiveEdges)\n\t\t{\n\t\t\treturn;\n\t\t} //already deleted\n\t\tif (AelPrev !== null)\n\t\t{\n\t\t\tAelPrev.NextInAEL = AelNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.m_ActiveEdges = AelNext;\n\t\t}\n\t\tif (AelNext !== null)\n\t\t{\n\t\t\tAelNext.PrevInAEL = AelPrev;\n\t\t}\n\t\te.NextInAEL = null;\n\t\te.PrevInAEL = null;\n\t}\n\n\t// public Clipper(int InitOptions = 0)\n\t/**\n\t * @suppress {missingProperties}\n\t */\n\tClipperLib.Clipper = function (InitOptions)\n\t{\n\t\tif (typeof (InitOptions) === \"undefined\") InitOptions = 0;\n\t\tthis.m_PolyOuts = null;\n\t\tthis.m_ClipType = ClipperLib.ClipType.ctIntersection;\n\t\tthis.m_Scanbeam = null;\n\t\tthis.m_Maxima = null;\n\t\tthis.m_ActiveEdges = null;\n\t\tthis.m_SortedEdges = null;\n\t\tthis.m_IntersectList = null;\n\t\tthis.m_IntersectNodeComparer = null;\n\t\tthis.m_ExecuteLocked = false;\n\t\tthis.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t\tthis.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t\tthis.m_Joins = null;\n\t\tthis.m_GhostJoins = null;\n\t\tthis.m_UsingPolyTree = false;\n\t\tthis.ReverseSolution = false;\n\t\tthis.StrictlySimple = false;\n\n\t\tClipperLib.ClipperBase.call(this);\n\n\t\tthis.m_Scanbeam = null;\n\t\tthis.m_Maxima = null;\n\t\tthis.m_ActiveEdges = null;\n\t\tthis.m_SortedEdges = null;\n\t\tthis.m_IntersectList = new Array();\n\t\tthis.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n\t\tthis.m_ExecuteLocked = false;\n\t\tthis.m_UsingPolyTree = false;\n\t\tthis.m_PolyOuts = new Array();\n\t\tthis.m_Joins = new Array();\n\t\tthis.m_GhostJoins = new Array();\n\t\tthis.ReverseSolution = (1 & InitOptions) !== 0;\n\t\tthis.StrictlySimple = (2 & InitOptions) !== 0;\n\t\tthis.PreserveCollinear = (4 & InitOptions) !== 0;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\tthis.ZFillFunction = null; // function (FPoint bot1, FPoint top1, FPoint bot2, FPoint top2, ref FPoint intersectPt);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.ioReverseSolution = 1;\n\tClipperLib.Clipper.ioStrictlySimple = 2;\n\tClipperLib.Clipper.ioPreserveCollinear = 4;\n\n\tClipperLib.Clipper.prototype.Clear = function ()\n\t{\n\t\tif (this.m_edges.length === 0)\n\t\t\treturn;\n\t\t//avoids problems with ClipperBase destructor\n\t\tthis.DisposeAllPolyPts();\n\t\tClipperLib.ClipperBase.prototype.Clear.call(this);\n\t};\n\n\tClipperLib.Clipper.prototype.InsertMaxima = function (X)\n\t{\n\t\t//double-linked list: sorted ascending, ignoring dups.\n\t\tvar newMax = new ClipperLib.Maxima();\n\t\tnewMax.X = X;\n\t\tif (this.m_Maxima === null)\n\t\t{\n\t\t\tthis.m_Maxima = newMax;\n\t\t\tthis.m_Maxima.Next = null;\n\t\t\tthis.m_Maxima.Prev = null;\n\t\t}\n\t\telse if (X < this.m_Maxima.X)\n\t\t{\n\t\t\tnewMax.Next = this.m_Maxima;\n\t\t\tnewMax.Prev = null;\n\t\t\tthis.m_Maxima = newMax;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar m = this.m_Maxima;\n\t\t\twhile (m.Next !== null && X >= m.Next.X)\n\t\t\t{\n\t\t\t\tm = m.Next;\n\t\t\t}\n\t\t\tif (X === m.X)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t} //ie ignores duplicates (& CG to clean up newMax)\n\t\t\t//insert newMax between m and m.Next ...\n\t\t\tnewMax.Next = m.Next;\n\t\t\tnewMax.Prev = m;\n\t\t\tif (m.Next !== null)\n\t\t\t{\n\t\t\t\tm.Next.Prev = newMax;\n\t\t\t}\n\t\t\tm.Next = newMax;\n\t\t}\n\t};\n\n\t// ************************************\n\tClipperLib.Clipper.prototype.Execute = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\talen = a.length,\n\t\t\tispolytree = a[1] instanceof ClipperLib.PolyTree;\n\t\tif (alen === 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n\t\t{\n\t\t\tvar clipType = a[0],\n\t\t\t\tsolution = a[1],\n\t\t\t\tsubjFillType = a[2],\n\t\t\t\tclipFillType = a[3];\n\t\t\tif (this.m_ExecuteLocked)\n\t\t\t\treturn false;\n\t\t\tif (this.m_HasOpenPaths)\n\t\t\t\tClipperLib.Error(\"Error: PolyTree struct is needed for open path clipping.\");\n\t\t\tthis.m_ExecuteLocked = true;\n\t\t\tClipperLib.Clear(solution);\n\t\t\tthis.m_SubjFillType = subjFillType;\n\t\t\tthis.m_ClipFillType = clipFillType;\n\t\t\tthis.m_ClipType = clipType;\n\t\t\tthis.m_UsingPolyTree = false;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar succeeded = this.ExecuteInternal();\n\t\t\t\t//build the return polygons ...\n\t\t\t\tif (succeeded) this.BuildResult(solution);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tthis.DisposeAllPolyPts();\n\t\t\t\tthis.m_ExecuteLocked = false;\n\t\t\t}\n\t\t\treturn succeeded;\n\t\t}\n\t\telse if (alen === 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n\t\t{\n\t\t\tvar clipType = a[0],\n\t\t\t\tpolytree = a[1],\n\t\t\t\tsubjFillType = a[2],\n\t\t\t\tclipFillType = a[3];\n\t\t\tif (this.m_ExecuteLocked)\n\t\t\t\treturn false;\n\t\t\tthis.m_ExecuteLocked = true;\n\t\t\tthis.m_SubjFillType = subjFillType;\n\t\t\tthis.m_ClipFillType = clipFillType;\n\t\t\tthis.m_ClipType = clipType;\n\t\t\tthis.m_UsingPolyTree = true;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar succeeded = this.ExecuteInternal();\n\t\t\t\t//build the return polygons ...\n\t\t\t\tif (succeeded) this.BuildResult2(polytree);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tthis.DisposeAllPolyPts();\n\t\t\t\tthis.m_ExecuteLocked = false;\n\t\t\t}\n\t\t\treturn succeeded;\n\t\t}\n\t\telse if (alen === 2 && !ispolytree) // function (clipType, solution)\n\t\t{\n\t\t\tvar clipType = a[0],\n\t\t\t\tsolution = a[1];\n\t\t\treturn this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t\t}\n\t\telse if (alen === 2 && ispolytree) // function (clipType, polytree)\n\t\t{\n\t\t\tvar clipType = a[0],\n\t\t\t\tpolytree = a[1];\n\t\t\treturn this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n\t{\n\t\t//skip if an outermost polygon or\n\t\t//already already points to the correct FirstLeft ...\n\t\tif (outRec.FirstLeft === null || (outRec.IsHole !== outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n\t\t\treturn;\n\t\tvar orfl = outRec.FirstLeft;\n\t\twhile (orfl !== null && ((orfl.IsHole === outRec.IsHole) || orfl.Pts === null))\n\t\t\torfl = orfl.FirstLeft;\n\t\toutRec.FirstLeft = orfl;\n\t};\n\n\tClipperLib.Clipper.prototype.ExecuteInternal = function ()\n\t{\n\t\ttry\n\t\t{\n\t\t\tthis.Reset();\n\t\t\tthis.m_SortedEdges = null;\n\t\t\tthis.m_Maxima = null;\n\n\t\t\tvar botY = {},\n\t\t\t\ttopY = {};\n\n\t\t\tif (!this.PopScanbeam(botY))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.InsertLocalMinimaIntoAEL(botY.v);\n\t\t\twhile (this.PopScanbeam(topY) || this.LocalMinimaPending())\n\t\t\t{\n\t\t\t\tthis.ProcessHorizontals();\n\t\t\t\tthis.m_GhostJoins.length = 0;\n\t\t\t\tif (!this.ProcessIntersections(topY.v))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tthis.ProcessEdgesAtTopOfScanbeam(topY.v);\n\t\t\t\tbotY.v = topY.v;\n\t\t\t\tthis.InsertLocalMinimaIntoAEL(botY.v);\n\t\t\t}\n\n\t\t\t//fix orientations ...\n\t\t\tvar outRec, i, ilen;\n\t\t\t//fix orientations ...\n\t\t\tfor (i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t\t{\n\t\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\t\tif (outRec.Pts === null || outRec.IsOpen) continue;\n\t\t\t\tif ((outRec.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec) > 0))\n\t\t\t\t\tthis.ReversePolyPtLinks(outRec.Pts);\n\t\t\t}\n\n\t\t\tthis.JoinCommonEdges();\n\n\t\t\tfor (i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t\t{\n\t\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\t\tif (outRec.Pts === null)\n\t\t\t\t\tcontinue;\n\t\t\t\telse if (outRec.IsOpen)\n\t\t\t\t\tthis.FixupOutPolyline(outRec);\n\t\t\t\telse\n\t\t\t\t\tthis.FixupOutPolygon(outRec);\n\t\t\t}\n\n\t\t\tif (this.StrictlySimple) this.DoSimplePolygons();\n\t\t\treturn true;\n\t\t}\n\t\t//catch { return false; }\n\t\tfinally\n\t\t{\n\t\t\tthis.m_Joins.length = 0;\n\t\t\tthis.m_GhostJoins.length = 0;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n\t{\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n\t\t\tthis.DisposeOutRec(i);\n\t\tClipperLib.Clear(this.m_PolyOuts);\n\t};\n\n\tClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n\t{\n\t\tvar j = new ClipperLib.Join();\n\t\tj.OutPt1 = Op1;\n\t\tj.OutPt2 = Op2;\n\t\t//j.OffPt = OffPt;\n\t\tj.OffPt.X = OffPt.X;\n\t\tj.OffPt.Y = OffPt.Y;\n\t\tif (ClipperLib.use_xyz) j.OffPt.Z = OffPt.Z;\n\t\tthis.m_Joins.push(j);\n\t};\n\n\tClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n\t{\n\t\tvar j = new ClipperLib.Join();\n\t\tj.OutPt1 = Op;\n\t\t//j.OffPt = OffPt;\n\t\tj.OffPt.X = OffPt.X;\n\t\tj.OffPt.Y = OffPt.Y;\n\t\tif (ClipperLib.use_xyz) j.OffPt.Z = OffPt.Z;\n\t\tthis.m_GhostJoins.push(j);\n\t};\n\n\t//if (ClipperLib.use_xyz)\n\t//{\n\tClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n\t{\n\t\tif (this.ZFillFunction !== null)\n\t\t{\n\t\t\tif (pt.Z !== 0 || this.ZFillFunction === null) return;\n\t\t\telse if (ClipperLib.FPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n\t\t\telse if (ClipperLib.FPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n\t\t\telse if (ClipperLib.FPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n\t\t\telse if (ClipperLib.FPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n\t\t\telse this.ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n\t\t}\n\t};\n\t//}\n\n\tClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n\t{\n\t\tvar lm = {};\n\n\t\tvar lb;\n\t\tvar rb;\n\t\twhile (this.PopLocalMinima(botY, lm))\n\t\t{\n\t\t\tlb = lm.v.LeftBound;\n\t\t\trb = lm.v.RightBound;\n\n\t\t\tvar Op1 = null;\n\t\t\tif (lb === null)\n\t\t\t{\n\t\t\t\tthis.InsertEdgeIntoAEL(rb, null);\n\t\t\t\tthis.SetWindingCount(rb);\n\t\t\t\tif (this.IsContributing(rb))\n\t\t\t\t\tOp1 = this.AddOutPt(rb, rb.Bot);\n\t\t\t}\n\t\t\telse if (rb === null)\n\t\t\t{\n\t\t\t\tthis.InsertEdgeIntoAEL(lb, null);\n\t\t\t\tthis.SetWindingCount(lb);\n\t\t\t\tif (this.IsContributing(lb))\n\t\t\t\t\tOp1 = this.AddOutPt(lb, lb.Bot);\n\t\t\t\tthis.InsertScanbeam(lb.Top.Y);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.InsertEdgeIntoAEL(lb, null);\n\t\t\t\tthis.InsertEdgeIntoAEL(rb, lb);\n\t\t\t\tthis.SetWindingCount(lb);\n\t\t\t\trb.WindCnt = lb.WindCnt;\n\t\t\t\trb.WindCnt2 = lb.WindCnt2;\n\t\t\t\tif (this.IsContributing(lb))\n\t\t\t\t\tOp1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n\t\t\t\tthis.InsertScanbeam(lb.Top.Y);\n\t\t\t}\n\t\t\tif (rb !== null)\n\t\t\t{\n\t\t\t\tif (ClipperLib.ClipperBase.IsHorizontal(rb))\n\t\t\t\t{\n\t\t\t\t\tif (rb.NextInLML !== null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.InsertScanbeam(rb.NextInLML.Top.Y);\n\t\t\t\t\t}\n\t\t\t\t\tthis.AddEdgeToSEL(rb);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.InsertScanbeam(rb.Top.Y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lb === null || rb === null) continue;\n\t\t\t//if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n\t\t\tif (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n\t\t\t{\n\t\t\t\tfor (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n\t\t\t\t{\n\t\t\t\t\t//if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n\t\t\t\t\t//the 'ghost' join to a real join ready for later ...\n\t\t\t\t\tvar j = this.m_GhostJoins[i];\n\n\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n\t\t\t\t\t\tthis.AddJoin(j.OutPt1, Op1, j.OffPt);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n\t\t\t\tlb.PrevInAEL.Curr.X === lb.Bot.X &&\n\t\t\t\tlb.PrevInAEL.OutIdx >= 0 &&\n\t\t\t\tClipperLib.ClipperBase.SlopesEqual5(lb.PrevInAEL.Curr, lb.PrevInAEL.Top, lb.Curr, lb.Top) &&\n\t\t\t\tlb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n\t\t\t{\n\t\t\t\tvar Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n\t\t\t\tthis.AddJoin(Op1, Op2, lb.Top);\n\t\t\t}\n\t\t\tif (lb.NextInAEL !== rb)\n\t\t\t{\n\t\t\t\tif (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n\t\t\t\t\tClipperLib.ClipperBase.SlopesEqual5(rb.PrevInAEL.Curr, rb.PrevInAEL.Top, rb.Curr, rb.Top) &&\n\t\t\t\t\trb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n\t\t\t\t{\n\t\t\t\t\tvar Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n\t\t\t\t\tthis.AddJoin(Op1, Op2, rb.Top);\n\t\t\t\t}\n\t\t\t\tvar e = lb.NextInAEL;\n\t\t\t\tif (e !== null)\n\t\t\t\t\twhile (e !== rb)\n\t\t\t\t\t{\n\t\t\t\t\t\t//nb: For calculating winding counts etc, IntersectEdges() assumes\n\t\t\t\t\t\t//that param1 will be to the right of param2 ABOVE the intersection ...\n\t\t\t\t\t\tthis.IntersectEdges(rb, e, lb.Curr);\n\t\t\t\t\t\t//order important here\n\t\t\t\t\t\te = e.NextInAEL;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n\t{\n\t\tif (this.m_ActiveEdges === null)\n\t\t{\n\t\t\tedge.PrevInAEL = null;\n\t\t\tedge.NextInAEL = null;\n\t\t\tthis.m_ActiveEdges = edge;\n\t\t}\n\t\telse if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n\t\t{\n\t\t\tedge.PrevInAEL = null;\n\t\t\tedge.NextInAEL = this.m_ActiveEdges;\n\t\t\tthis.m_ActiveEdges.PrevInAEL = edge;\n\t\t\tthis.m_ActiveEdges = edge;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (startEdge === null)\n\t\t\t\tstartEdge = this.m_ActiveEdges;\n\t\t\twhile (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n\t\t\t\tstartEdge = startEdge.NextInAEL;\n\t\t\tedge.NextInAEL = startEdge.NextInAEL;\n\t\t\tif (startEdge.NextInAEL !== null)\n\t\t\t\tstartEdge.NextInAEL.PrevInAEL = edge;\n\t\t\tedge.PrevInAEL = startEdge;\n\t\t\tstartEdge.NextInAEL = edge;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n\t{\n\t\tif (e2.Curr.X === e1.Curr.X)\n\t\t{\n\t\t\tif (e2.Top.Y > e1.Top.Y)\n\t\t\t\treturn e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n\t\t\telse\n\t\t\t\treturn e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n\t\t}\n\t\telse\n\t\t\treturn e2.Curr.X < e1.Curr.X;\n\t};\n\n\tClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n\t{\n\t\tif (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t\treturn this.m_SubjFillType === ClipperLib.PolyFillType.pftEvenOdd;\n\t\telse\n\t\t\treturn this.m_ClipFillType === ClipperLib.PolyFillType.pftEvenOdd;\n\t};\n\n\tClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n\t{\n\t\tif (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t\treturn this.m_ClipFillType === ClipperLib.PolyFillType.pftEvenOdd;\n\t\telse\n\t\t\treturn this.m_SubjFillType === ClipperLib.PolyFillType.pftEvenOdd;\n\t};\n\n\tClipperLib.Clipper.prototype.IsContributing = function (edge)\n\t{\n\t\tvar pft, pft2;\n\t\tif (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t{\n\t\t\tpft = this.m_SubjFillType;\n\t\t\tpft2 = this.m_ClipFillType;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpft = this.m_ClipFillType;\n\t\t\tpft2 = this.m_SubjFillType;\n\t\t}\n\t\tswitch (pft)\n\t\t{\n\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\tif (edge.WindDelta === 0 && edge.WindCnt !== 1)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\tif (Math.abs(edge.WindCnt) !== 1)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\tif (edge.WindCnt !== 1)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (edge.WindCnt !== -1)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (this.m_ClipType)\n\t\t{\n\t\tcase ClipperLib.ClipType.ctIntersection:\n\t\t\tswitch (pft2)\n\t\t\t{\n\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\treturn (edge.WindCnt2 !== 0);\n\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\treturn (edge.WindCnt2 > 0);\n\t\t\tdefault:\n\t\t\t\treturn (edge.WindCnt2 < 0);\n\t\t\t}\n\t\tcase ClipperLib.ClipType.ctUnion:\n\t\t\tswitch (pft2)\n\t\t\t{\n\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\treturn (edge.WindCnt2 === 0);\n\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\treturn (edge.WindCnt2 <= 0);\n\t\t\tdefault:\n\t\t\t\treturn (edge.WindCnt2 >= 0);\n\t\t\t}\n\t\tcase ClipperLib.ClipType.ctDifference:\n\t\t\tif (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t\t\tswitch (pft2)\n\t\t\t\t{\n\t\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\t\treturn (edge.WindCnt2 === 0);\n\t\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\t\treturn (edge.WindCnt2 <= 0);\n\t\t\t\tdefault:\n\t\t\t\t\treturn (edge.WindCnt2 >= 0);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tswitch (pft2)\n\t\t\t\t{\n\t\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\t\treturn (edge.WindCnt2 !== 0);\n\t\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\t\treturn (edge.WindCnt2 > 0);\n\t\t\t\tdefault:\n\t\t\t\t\treturn (edge.WindCnt2 < 0);\n\t\t\t\t}\n\t\tcase ClipperLib.ClipType.ctXor:\n\t\t\tif (edge.WindDelta === 0)\n\t\t\t\tswitch (pft2)\n\t\t\t\t{\n\t\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\t\treturn (edge.WindCnt2 === 0);\n\t\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\t\treturn (edge.WindCnt2 <= 0);\n\t\t\t\tdefault:\n\t\t\t\t\treturn (edge.WindCnt2 >= 0);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n\t{\n\t\tvar e = edge.PrevInAEL;\n\t\t//find the edge of the same polytype that immediately preceeds 'edge' in AEL\n\t\twhile (e !== null && ((e.PolyTyp !== edge.PolyTyp) || (e.WindDelta === 0)))\n\t\t\te = e.PrevInAEL;\n\t\tif (e === null)\n\t\t{\n\t\t\tvar pft = (edge.PolyTyp === ClipperLib.PolyType.ptSubject ? this.m_SubjFillType : this.m_ClipFillType);\n\t\t\tif (edge.WindDelta === 0)\n\t\t\t{\n\t\t\t\tedge.WindCnt = (pft === ClipperLib.PolyFillType.pftNegative ? -1 : 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tedge.WindCnt = edge.WindDelta;\n\t\t\t}\n\t\t\tedge.WindCnt2 = 0;\n\t\t\te = this.m_ActiveEdges;\n\t\t\t//ie get ready to calc WindCnt2\n\t\t}\n\t\telse if (edge.WindDelta === 0 && this.m_ClipType !== ClipperLib.ClipType.ctUnion)\n\t\t{\n\t\t\tedge.WindCnt = 1;\n\t\t\tedge.WindCnt2 = e.WindCnt2;\n\t\t\te = e.NextInAEL;\n\t\t\t//ie get ready to calc WindCnt2\n\t\t}\n\t\telse if (this.IsEvenOddFillType(edge))\n\t\t{\n\t\t\t//EvenOdd filling ...\n\t\t\tif (edge.WindDelta === 0)\n\t\t\t{\n\t\t\t\t//are we inside a subj polygon ...\n\t\t\t\tvar Inside = true;\n\t\t\t\tvar e2 = e.PrevInAEL;\n\t\t\t\twhile (e2 !== null)\n\t\t\t\t{\n\t\t\t\t\tif (e2.PolyTyp === e.PolyTyp && e2.WindDelta !== 0)\n\t\t\t\t\t\tInside = !Inside;\n\t\t\t\t\te2 = e2.PrevInAEL;\n\t\t\t\t}\n\t\t\t\tedge.WindCnt = (Inside ? 0 : 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tedge.WindCnt = edge.WindDelta;\n\t\t\t}\n\t\t\tedge.WindCnt2 = e.WindCnt2;\n\t\t\te = e.NextInAEL;\n\t\t\t//ie get ready to calc WindCnt2\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//nonZero, Positive or Negative filling ...\n\t\t\tif (e.WindCnt * e.WindDelta < 0)\n\t\t\t{\n\t\t\t\t//prev edge is 'decreasing' WindCount (WC) toward zero\n\t\t\t\t//so we're outside the previous polygon ...\n\t\t\t\tif (Math.abs(e.WindCnt) > 1)\n\t\t\t\t{\n\t\t\t\t\t//outside prev poly but still inside another.\n\t\t\t\t\t//when reversing direction of prev poly use the same WC\n\t\t\t\t\tif (e.WindDelta * edge.WindDelta < 0)\n\t\t\t\t\t\tedge.WindCnt = e.WindCnt;\n\t\t\t\t\telse\n\t\t\t\t\t\tedge.WindCnt = e.WindCnt + edge.WindDelta;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tedge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//prev edge is 'increasing' WindCount (WC) away from zero\n\t\t\t\t//so we're inside the previous polygon ...\n\t\t\t\tif (edge.WindDelta === 0)\n\t\t\t\t\tedge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n\t\t\t\telse if (e.WindDelta * edge.WindDelta < 0)\n\t\t\t\t\tedge.WindCnt = e.WindCnt;\n\t\t\t\telse\n\t\t\t\t\tedge.WindCnt = e.WindCnt + edge.WindDelta;\n\t\t\t}\n\t\t\tedge.WindCnt2 = e.WindCnt2;\n\t\t\te = e.NextInAEL;\n\t\t\t//ie get ready to calc WindCnt2\n\t\t}\n\t\t//update WindCnt2 ...\n\t\tif (this.IsEvenOddAltFillType(edge))\n\t\t{\n\t\t\t//EvenOdd filling ...\n\t\t\twhile (e !== edge)\n\t\t\t{\n\t\t\t\tif (e.WindDelta !== 0)\n\t\t\t\t\tedge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n\t\t\t\te = e.NextInAEL;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//nonZero, Positive or Negative filling ...\n\t\t\twhile (e !== edge)\n\t\t\t{\n\t\t\t\tedge.WindCnt2 += e.WindDelta;\n\t\t\t\te = e.NextInAEL;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n\t{\n\t\t//SEL pointers in PEdge are use to build transient lists of horizontal edges.\n\t\t//However, since we don't need to worry about processing order, all additions\n\t\t//are made to the front of the list ...\n\t\tif (this.m_SortedEdges === null)\n\t\t{\n\t\t\tthis.m_SortedEdges = edge;\n\t\t\tedge.PrevInSEL = null;\n\t\t\tedge.NextInSEL = null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tedge.NextInSEL = this.m_SortedEdges;\n\t\t\tedge.PrevInSEL = null;\n\t\t\tthis.m_SortedEdges.PrevInSEL = edge;\n\t\t\tthis.m_SortedEdges = edge;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.PopEdgeFromSEL = function (e)\n\t{\n\t\t//Pop edge from front of SEL (ie SEL is a FILO list)\n\t\te.v = this.m_SortedEdges;\n\t\tif (e.v === null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tvar oldE = e.v;\n\t\tthis.m_SortedEdges = e.v.NextInSEL;\n\t\tif (this.m_SortedEdges !== null)\n\t\t{\n\t\t\tthis.m_SortedEdges.PrevInSEL = null;\n\t\t}\n\t\toldE.NextInSEL = null;\n\t\toldE.PrevInSEL = null;\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n\t{\n\t\tvar e = this.m_ActiveEdges;\n\t\tthis.m_SortedEdges = e;\n\t\twhile (e !== null)\n\t\t{\n\t\t\te.PrevInSEL = e.PrevInAEL;\n\t\t\te.NextInSEL = e.NextInAEL;\n\t\t\te = e.NextInAEL;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n\t{\n\t\tif (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n\t\t\treturn;\n\t\tif (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n\t\t\treturn;\n\t\tif (edge1.NextInSEL === edge2)\n\t\t{\n\t\t\tvar next = edge2.NextInSEL;\n\t\t\tif (next !== null)\n\t\t\t\tnext.PrevInSEL = edge1;\n\t\t\tvar prev = edge1.PrevInSEL;\n\t\t\tif (prev !== null)\n\t\t\t\tprev.NextInSEL = edge2;\n\t\t\tedge2.PrevInSEL = prev;\n\t\t\tedge2.NextInSEL = edge1;\n\t\t\tedge1.PrevInSEL = edge2;\n\t\t\tedge1.NextInSEL = next;\n\t\t}\n\t\telse if (edge2.NextInSEL === edge1)\n\t\t{\n\t\t\tvar next = edge1.NextInSEL;\n\t\t\tif (next !== null)\n\t\t\t\tnext.PrevInSEL = edge2;\n\t\t\tvar prev = edge2.PrevInSEL;\n\t\t\tif (prev !== null)\n\t\t\t\tprev.NextInSEL = edge1;\n\t\t\tedge1.PrevInSEL = prev;\n\t\t\tedge1.NextInSEL = edge2;\n\t\t\tedge2.PrevInSEL = edge1;\n\t\t\tedge2.NextInSEL = next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar next = edge1.NextInSEL;\n\t\t\tvar prev = edge1.PrevInSEL;\n\t\t\tedge1.NextInSEL = edge2.NextInSEL;\n\t\t\tif (edge1.NextInSEL !== null)\n\t\t\t\tedge1.NextInSEL.PrevInSEL = edge1;\n\t\t\tedge1.PrevInSEL = edge2.PrevInSEL;\n\t\t\tif (edge1.PrevInSEL !== null)\n\t\t\t\tedge1.PrevInSEL.NextInSEL = edge1;\n\t\t\tedge2.NextInSEL = next;\n\t\t\tif (edge2.NextInSEL !== null)\n\t\t\t\tedge2.NextInSEL.PrevInSEL = edge2;\n\t\t\tedge2.PrevInSEL = prev;\n\t\t\tif (edge2.PrevInSEL !== null)\n\t\t\t\tedge2.PrevInSEL.NextInSEL = edge2;\n\t\t}\n\t\tif (edge1.PrevInSEL === null)\n\t\t\tthis.m_SortedEdges = edge1;\n\t\telse if (edge2.PrevInSEL === null)\n\t\t\tthis.m_SortedEdges = edge2;\n\t};\n\n\tClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n\t{\n\t\tthis.AddOutPt(e1, pt);\n\t\tif (e2.WindDelta === 0) this.AddOutPt(e2, pt);\n\t\tif (e1.OutIdx === e2.OutIdx)\n\t\t{\n\t\t\te1.OutIdx = -1;\n\t\t\te2.OutIdx = -1;\n\t\t}\n\t\telse if (e1.OutIdx < e2.OutIdx)\n\t\t\tthis.AppendPolygon(e1, e2);\n\t\telse\n\t\t\tthis.AppendPolygon(e2, e1);\n\t};\n\n\tClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n\t{\n\t\tvar result;\n\t\tvar e, prevE;\n\t\tif (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n\t\t{\n\t\t\tresult = this.AddOutPt(e1, pt);\n\t\t\te2.OutIdx = e1.OutIdx;\n\t\t\te1.Side = ClipperLib.EdgeSide.esLeft;\n\t\t\te2.Side = ClipperLib.EdgeSide.esRight;\n\t\t\te = e1;\n\t\t\tif (e.PrevInAEL === e2)\n\t\t\t\tprevE = e2.PrevInAEL;\n\t\t\telse\n\t\t\t\tprevE = e.PrevInAEL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = this.AddOutPt(e2, pt);\n\t\t\te1.OutIdx = e2.OutIdx;\n\t\t\te1.Side = ClipperLib.EdgeSide.esRight;\n\t\t\te2.Side = ClipperLib.EdgeSide.esLeft;\n\t\t\te = e2;\n\t\t\tif (e.PrevInAEL === e1)\n\t\t\t\tprevE = e1.PrevInAEL;\n\t\t\telse\n\t\t\t\tprevE = e.PrevInAEL;\n\t\t}\n\n\t\tif (prevE !== null && prevE.OutIdx >= 0 && prevE.Top.Y < pt.Y && e.Top.Y < pt.Y)\n\t\t{\n\t\t\tvar xPrev = ClipperLib.Clipper.TopX(prevE, pt.Y);\n\t\t\tvar xE = ClipperLib.Clipper.TopX(e, pt.Y);\n\t\t\tif ((xPrev === xE) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0) && ClipperLib.ClipperBase.SlopesEqual5(new ClipperLib.FPoint2(xPrev, pt.Y), prevE.Top, new ClipperLib.FPoint2(xE, pt.Y), e.Top))\n\t\t\t{\n\t\t\t\tvar outPt = this.AddOutPt(prevE, pt);\n\t\t\t\tthis.AddJoin(result, outPt, e.Top);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n\t{\n\t\tif (e.OutIdx < 0)\n\t\t{\n\t\t\tvar outRec = this.CreateOutRec();\n\t\t\toutRec.IsOpen = (e.WindDelta === 0);\n\t\t\tvar newOp = new ClipperLib.OutPt();\n\t\t\toutRec.Pts = newOp;\n\t\t\tnewOp.Idx = outRec.Idx;\n\t\t\t//newOp.Pt = pt;\n\t\t\tnewOp.Pt.X = pt.X;\n\t\t\tnewOp.Pt.Y = pt.Y;\n\t\t\tif (ClipperLib.use_xyz) newOp.Pt.Z = pt.Z;\n\t\t\tnewOp.Next = newOp;\n\t\t\tnewOp.Prev = newOp;\n\t\t\tif (!outRec.IsOpen)\n\t\t\t\tthis.SetHoleState(e, outRec);\n\t\t\te.OutIdx = outRec.Idx;\n\t\t\t//nb: do this after SetZ !\n\t\t\treturn newOp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar outRec = this.m_PolyOuts[e.OutIdx];\n\t\t\t//OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n\t\t\tvar op = outRec.Pts;\n\t\t\tvar ToFront = (e.Side === ClipperLib.EdgeSide.esLeft);\n\t\t\tif (ToFront && ClipperLib.FPoint.op_Equality(pt, op.Pt))\n\t\t\t\treturn op;\n\t\t\telse if (!ToFront && ClipperLib.FPoint.op_Equality(pt, op.Prev.Pt))\n\t\t\t\treturn op.Prev;\n\t\t\tvar newOp = new ClipperLib.OutPt();\n\t\t\tnewOp.Idx = outRec.Idx;\n\t\t\t//newOp.Pt = pt;\n\t\t\tnewOp.Pt.X = pt.X;\n\t\t\tnewOp.Pt.Y = pt.Y;\n\t\t\tif (ClipperLib.use_xyz) newOp.Pt.Z = pt.Z;\n\t\t\tnewOp.Next = op;\n\t\t\tnewOp.Prev = op.Prev;\n\t\t\tnewOp.Prev.Next = newOp;\n\t\t\top.Prev = newOp;\n\t\t\tif (ToFront)\n\t\t\t\toutRec.Pts = newOp;\n\t\t\treturn newOp;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetLastOutPt = function (e)\n\t{\n\t\tvar outRec = this.m_PolyOuts[e.OutIdx];\n\t\tif (e.Side === ClipperLib.EdgeSide.esLeft)\n\t\t{\n\t\t\treturn outRec.Pts;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn outRec.Pts.Prev;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n\t{\n\t\tvar tmp = new ClipperLib.FPoint1(pt1.Value);\n\t\t//pt1.Value = pt2.Value;\n\t\tpt1.Value.X = pt2.Value.X;\n\t\tpt1.Value.Y = pt2.Value.Y;\n\t\tif (ClipperLib.use_xyz) pt1.Value.Z = pt2.Value.Z;\n\t\t//pt2.Value = tmp;\n\t\tpt2.Value.X = tmp.X;\n\t\tpt2.Value.Y = tmp.Y;\n\t\tif (ClipperLib.use_xyz) pt2.Value.Z = tmp.Z;\n\t};\n\n\tClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t{\n\t\tvar tmp;\n\t\tif (seg1a > seg1b)\n\t\t{\n\t\t\ttmp = seg1a;\n\t\t\tseg1a = seg1b;\n\t\t\tseg1b = tmp;\n\t\t}\n\t\tif (seg2a > seg2b)\n\t\t{\n\t\t\ttmp = seg2a;\n\t\t\tseg2a = seg2b;\n\t\t\tseg2b = tmp;\n\t\t}\n\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t}\n\n\tClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n\t{\n\t\tvar e2 = e.PrevInAEL;\n\t\tvar eTmp = null;\n\t\twhile (e2 !== null)\n\t\t{\n\t\t\tif (e2.OutIdx >= 0 && e2.WindDelta !== 0)\n\t\t\t{\n\t\t\t\tif (eTmp === null)\n\t\t\t\t\teTmp = e2;\n\t\t\t\telse if (eTmp.OutIdx === e2.OutIdx)\n\t\t\t\t\teTmp = null; //paired\n\t\t\t}\n\t\t\te2 = e2.PrevInAEL;\n\t\t}\n\n\t\tif (eTmp === null)\n\t\t{\n\t\t\toutRec.FirstLeft = null;\n\t\t\toutRec.IsHole = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutRec.FirstLeft = this.m_PolyOuts[eTmp.OutIdx];\n\t\t\toutRec.IsHole = !outRec.FirstLeft.IsHole;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n\t{\n\t\tif (pt1.Y === pt2.Y)\n\t\t\treturn ClipperLib.ClipperBase.horizontal;\n\t\telse\n\t\t\treturn (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n\t};\n\n\tClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n\t{\n\t\tvar p = btmPt1.Prev;\n\t\twhile ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p !== btmPt1))\n\t\t\tp = p.Prev;\n\t\tvar dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t\tp = btmPt1.Next;\n\t\twhile ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p !== btmPt1))\n\t\t\tp = p.Next;\n\t\tvar dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t\tp = btmPt2.Prev;\n\t\twhile ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p !== btmPt2))\n\t\t\tp = p.Prev;\n\t\tvar dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t\tp = btmPt2.Next;\n\t\twhile ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p !== btmPt2))\n\t\t\tp = p.Next;\n\t\tvar dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\n\t\tif (Math.max(dx1p, dx1n) === Math.max(dx2p, dx2n) && Math.min(dx1p, dx1n) === Math.min(dx2p, dx2n))\n\t\t{\n\t\t\treturn this.Area(btmPt1) > 0; //if otherwise identical use orientation\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n\t{\n\t\tvar dups = null;\n\t\tvar p = pp.Next;\n\t\twhile (p !== pp)\n\t\t{\n\t\t\tif (p.Pt.Y > pp.Pt.Y)\n\t\t\t{\n\t\t\t\tpp = p;\n\t\t\t\tdups = null;\n\t\t\t}\n\t\t\telse if (p.Pt.Y === pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n\t\t\t{\n\t\t\t\tif (p.Pt.X < pp.Pt.X)\n\t\t\t\t{\n\t\t\t\t\tdups = null;\n\t\t\t\t\tpp = p;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (p.Next !== pp && p.Prev !== pp)\n\t\t\t\t\t\tdups = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = p.Next;\n\t\t}\n\t\tif (dups !== null)\n\t\t{\n\t\t\t//there appears to be at least 2 vertices at bottomPt so ...\n\t\t\twhile (dups !== p)\n\t\t\t{\n\t\t\t\tif (!this.FirstIsBottomPt(p, dups))\n\t\t\t\t\tpp = dups;\n\t\t\t\tdups = dups.Next;\n\t\t\t\twhile (ClipperLib.FPoint.op_Inequality(dups.Pt, pp.Pt))\n\t\t\t\t\tdups = dups.Next;\n\t\t\t}\n\t\t}\n\t\treturn pp;\n\t};\n\n\tClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n\t{\n\t\t//work out which polygon fragment has the correct hole state ...\n\t\tif (outRec1.BottomPt === null)\n\t\t\toutRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n\t\tif (outRec2.BottomPt === null)\n\t\t\toutRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n\t\tvar bPt1 = outRec1.BottomPt;\n\t\tvar bPt2 = outRec2.BottomPt;\n\t\tif (bPt1.Pt.Y > bPt2.Pt.Y)\n\t\t\treturn outRec1;\n\t\telse if (bPt1.Pt.Y < bPt2.Pt.Y)\n\t\t\treturn outRec2;\n\t\telse if (bPt1.Pt.X < bPt2.Pt.X)\n\t\t\treturn outRec1;\n\t\telse if (bPt1.Pt.X > bPt2.Pt.X)\n\t\t\treturn outRec2;\n\t\telse if (bPt1.Next === bPt1)\n\t\t\treturn outRec2;\n\t\telse if (bPt2.Next === bPt2)\n\t\t\treturn outRec1;\n\t\telse if (this.FirstIsBottomPt(bPt1, bPt2))\n\t\t\treturn outRec1;\n\t\telse\n\t\t\treturn outRec2;\n\t};\n\n\tClipperLib.Clipper.prototype.OutRec1RightOfOutRec2 = function (outRec1, outRec2)\n\t{\n\t\tdo {\n\t\t\toutRec1 = outRec1.FirstLeft;\n\t\t\tif (outRec1 === outRec2)\n\t\t\t\treturn true;\n\t\t}\n\t\twhile (outRec1 !== null)\n\t\treturn false;\n\t};\n\n\tClipperLib.Clipper.prototype.GetOutRec = function (idx)\n\t{\n\t\tvar outrec = this.m_PolyOuts[idx];\n\t\twhile (outrec !== this.m_PolyOuts[outrec.Idx])\n\t\t\toutrec = this.m_PolyOuts[outrec.Idx];\n\t\treturn outrec;\n\t};\n\n\tClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n\t{\n\t\t//get the start and ends of both output polygons ...\n\t\tvar outRec1 = this.m_PolyOuts[e1.OutIdx];\n\t\tvar outRec2 = this.m_PolyOuts[e2.OutIdx];\n\t\tvar holeStateRec;\n\t\tif (this.OutRec1RightOfOutRec2(outRec1, outRec2))\n\t\t\tholeStateRec = outRec2;\n\t\telse if (this.OutRec1RightOfOutRec2(outRec2, outRec1))\n\t\t\tholeStateRec = outRec1;\n\t\telse\n\t\t\tholeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n\t\t//get the start and ends of both output polygons and\n\t\t//join E2 poly onto E1 poly and delete pointers to E2 ...\n\n\t\tvar p1_lft = outRec1.Pts;\n\t\tvar p1_rt = p1_lft.Prev;\n\t\tvar p2_lft = outRec2.Pts;\n\t\tvar p2_rt = p2_lft.Prev;\n\t\t//join e2 poly onto e1 poly and delete pointers to e2 ...\n\t\tif (e1.Side === ClipperLib.EdgeSide.esLeft)\n\t\t{\n\t\t\tif (e2.Side === ClipperLib.EdgeSide.esLeft)\n\t\t\t{\n\t\t\t\t//z y x a b c\n\t\t\t\tthis.ReversePolyPtLinks(p2_lft);\n\t\t\t\tp2_lft.Next = p1_lft;\n\t\t\t\tp1_lft.Prev = p2_lft;\n\t\t\t\tp1_rt.Next = p2_rt;\n\t\t\t\tp2_rt.Prev = p1_rt;\n\t\t\t\toutRec1.Pts = p2_rt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//x y z a b c\n\t\t\t\tp2_rt.Next = p1_lft;\n\t\t\t\tp1_lft.Prev = p2_rt;\n\t\t\t\tp2_lft.Prev = p1_rt;\n\t\t\t\tp1_rt.Next = p2_lft;\n\t\t\t\toutRec1.Pts = p2_lft;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (e2.Side === ClipperLib.EdgeSide.esRight)\n\t\t\t{\n\t\t\t\t//a b c z y x\n\t\t\t\tthis.ReversePolyPtLinks(p2_lft);\n\t\t\t\tp1_rt.Next = p2_rt;\n\t\t\t\tp2_rt.Prev = p1_rt;\n\t\t\t\tp2_lft.Next = p1_lft;\n\t\t\t\tp1_lft.Prev = p2_lft;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//a b c x y z\n\t\t\t\tp1_rt.Next = p2_lft;\n\t\t\t\tp2_lft.Prev = p1_rt;\n\t\t\t\tp1_lft.Prev = p2_rt;\n\t\t\t\tp2_rt.Next = p1_lft;\n\t\t\t}\n\t\t}\n\t\toutRec1.BottomPt = null;\n\t\tif (holeStateRec === outRec2)\n\t\t{\n\t\t\tif (outRec2.FirstLeft !== outRec1)\n\t\t\t\toutRec1.FirstLeft = outRec2.FirstLeft;\n\t\t\toutRec1.IsHole = outRec2.IsHole;\n\t\t}\n\t\toutRec2.Pts = null;\n\t\toutRec2.BottomPt = null;\n\t\toutRec2.FirstLeft = outRec1;\n\t\tvar OKIdx = e1.OutIdx;\n\t\tvar ObsoleteIdx = e2.OutIdx;\n\t\te1.OutIdx = -1;\n\t\t//nb: safe because we only get here via AddLocalMaxPoly\n\t\te2.OutIdx = -1;\n\t\tvar e = this.m_ActiveEdges;\n\t\twhile (e !== null)\n\t\t{\n\t\t\tif (e.OutIdx === ObsoleteIdx)\n\t\t\t{\n\t\t\t\te.OutIdx = OKIdx;\n\t\t\t\te.Side = e1.Side;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = e.NextInAEL;\n\t\t}\n\t\toutRec2.Idx = outRec1.Idx;\n\t};\n\n\tClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n\t{\n\t\tif (pp === null)\n\t\t\treturn;\n\t\tvar pp1;\n\t\tvar pp2;\n\t\tpp1 = pp;\n\t\tdo {\n\t\t\tpp2 = pp1.Next;\n\t\t\tpp1.Next = pp1.Prev;\n\t\t\tpp1.Prev = pp2;\n\t\t\tpp1 = pp2;\n\t\t}\n\t\twhile (pp1 !== pp)\n\t};\n\n\tClipperLib.Clipper.SwapSides = function (edge1, edge2)\n\t{\n\t\tvar side = edge1.Side;\n\t\tedge1.Side = edge2.Side;\n\t\tedge2.Side = side;\n\t};\n\n\tClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n\t{\n\t\tvar outIdx = edge1.OutIdx;\n\t\tedge1.OutIdx = edge2.OutIdx;\n\t\tedge2.OutIdx = outIdx;\n\t};\n\n\tClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n\t{\n\t\t//e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n\t\t//e2 in AEL except when e1 is being inserted at the intersection point ...\n\t\tvar e1Contributing = (e1.OutIdx >= 0);\n\t\tvar e2Contributing = (e2.OutIdx >= 0);\n\n\t\tif (ClipperLib.use_xyz)\n\t\t\tthis.SetZ(pt, e1, e2);\n\n\t\tif (ClipperLib.use_lines)\n\t\t{\n\t\t\t//if either edge is on an OPEN path ...\n\t\t\tif (e1.WindDelta === 0 || e2.WindDelta === 0)\n\t\t\t{\n\t\t\t\t//ignore subject-subject open path intersections UNLESS they\n\t\t\t\t//are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\tif (e1.WindDelta === 0 && e2.WindDelta === 0) return;\n\t\t\t\t//if intersecting a subj line with a subj poly ...\n\t\t\t\telse if (e1.PolyTyp === e2.PolyTyp &&\n\t\t\t\t\te1.WindDelta !== e2.WindDelta && this.m_ClipType === ClipperLib.ClipType.ctUnion)\n\t\t\t\t{\n\t\t\t\t\tif (e1.WindDelta === 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (e2Contributing)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.AddOutPt(e1, pt);\n\t\t\t\t\t\t\tif (e1Contributing)\n\t\t\t\t\t\t\t\te1.OutIdx = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (e1Contributing)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.AddOutPt(e2, pt);\n\t\t\t\t\t\t\tif (e2Contributing)\n\t\t\t\t\t\t\t\te2.OutIdx = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (e1.PolyTyp !== e2.PolyTyp)\n\t\t\t\t{\n\t\t\t\t\tif ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) === 1 &&\n\t\t\t\t\t\t(this.m_ClipType !== ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.AddOutPt(e1, pt);\n\t\t\t\t\t\tif (e1Contributing)\n\t\t\t\t\t\t\te1.OutIdx = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) === 1) &&\n\t\t\t\t\t\t(this.m_ClipType !== ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.AddOutPt(e2, pt);\n\t\t\t\t\t\tif (e2Contributing)\n\t\t\t\t\t\t\te2.OutIdx = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t//update winding counts...\n\t\t//assumes that e1 will be to the Right of e2 ABOVE the intersection\n\t\tif (e1.PolyTyp === e2.PolyTyp)\n\t\t{\n\t\t\tif (this.IsEvenOddFillType(e1))\n\t\t\t{\n\t\t\t\tvar oldE1WindCnt = e1.WindCnt;\n\t\t\t\te1.WindCnt = e2.WindCnt;\n\t\t\t\te2.WindCnt = oldE1WindCnt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (e1.WindCnt + e2.WindDelta === 0)\n\t\t\t\t\te1.WindCnt = -e1.WindCnt;\n\t\t\t\telse\n\t\t\t\t\te1.WindCnt += e2.WindDelta;\n\t\t\t\tif (e2.WindCnt - e1.WindDelta === 0)\n\t\t\t\t\te2.WindCnt = -e2.WindCnt;\n\t\t\t\telse\n\t\t\t\t\te2.WindCnt -= e1.WindDelta;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!this.IsEvenOddFillType(e2))\n\t\t\t\te1.WindCnt2 += e2.WindDelta;\n\t\t\telse\n\t\t\t\te1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n\t\t\tif (!this.IsEvenOddFillType(e1))\n\t\t\t\te2.WindCnt2 -= e1.WindDelta;\n\t\t\telse\n\t\t\t\te2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n\t\t}\n\t\tvar e1FillType, e2FillType, e1FillType2, e2FillType2;\n\t\tif (e1.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t{\n\t\t\te1FillType = this.m_SubjFillType;\n\t\t\te1FillType2 = this.m_ClipFillType;\n\t\t}\n\t\telse\n\t\t{\n\t\t\te1FillType = this.m_ClipFillType;\n\t\t\te1FillType2 = this.m_SubjFillType;\n\t\t}\n\t\tif (e2.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t{\n\t\t\te2FillType = this.m_SubjFillType;\n\t\t\te2FillType2 = this.m_ClipFillType;\n\t\t}\n\t\telse\n\t\t{\n\t\t\te2FillType = this.m_ClipFillType;\n\t\t\te2FillType2 = this.m_SubjFillType;\n\t\t}\n\t\tvar e1Wc, e2Wc;\n\t\tswitch (e1FillType)\n\t\t{\n\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\te1Wc = e1.WindCnt;\n\t\t\tbreak;\n\t\tcase ClipperLib.PolyFillType.pftNegative:\n\t\t\te1Wc = -e1.WindCnt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te1Wc = Math.abs(e1.WindCnt);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (e2FillType)\n\t\t{\n\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\te2Wc = e2.WindCnt;\n\t\t\tbreak;\n\t\tcase ClipperLib.PolyFillType.pftNegative:\n\t\t\te2Wc = -e2.WindCnt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te2Wc = Math.abs(e2.WindCnt);\n\t\t\tbreak;\n\t\t}\n\t\tif (e1Contributing && e2Contributing)\n\t\t{\n\t\t\tif ((e1Wc !== 0 && e1Wc !== 1) || (e2Wc !== 0 && e2Wc !== 1) ||\n\t\t\t\t(e1.PolyTyp !== e2.PolyTyp && this.m_ClipType !== ClipperLib.ClipType.ctXor))\n\t\t\t{\n\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.AddOutPt(e1, pt);\n\t\t\t\tthis.AddOutPt(e2, pt);\n\t\t\t\tClipperLib.Clipper.SwapSides(e1, e2);\n\t\t\t\tClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t\t\t}\n\t\t}\n\t\telse if (e1Contributing)\n\t\t{\n\t\t\tif (e2Wc === 0 || e2Wc === 1)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(e1, pt);\n\t\t\t\tClipperLib.Clipper.SwapSides(e1, e2);\n\t\t\t\tClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t\t\t}\n\t\t}\n\t\telse if (e2Contributing)\n\t\t{\n\t\t\tif (e1Wc === 0 || e1Wc === 1)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(e2, pt);\n\t\t\t\tClipperLib.Clipper.SwapSides(e1, e2);\n\t\t\t\tClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t\t\t}\n\t\t}\n\t\telse if ((e1Wc === 0 || e1Wc === 1) && (e2Wc === 0 || e2Wc === 1))\n\t\t{\n\t\t\t//neither edge is currently contributing ...\n\t\t\tvar e1Wc2, e2Wc2;\n\t\t\tswitch (e1FillType2)\n\t\t\t{\n\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\te1Wc2 = e1.WindCnt2;\n\t\t\t\tbreak;\n\t\t\tcase ClipperLib.PolyFillType.pftNegative:\n\t\t\t\te1Wc2 = -e1.WindCnt2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\te1Wc2 = Math.abs(e1.WindCnt2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (e2FillType2)\n\t\t\t{\n\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\te2Wc2 = e2.WindCnt2;\n\t\t\t\tbreak;\n\t\t\tcase ClipperLib.PolyFillType.pftNegative:\n\t\t\t\te2Wc2 = -e2.WindCnt2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\te2Wc2 = Math.abs(e2.WindCnt2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (e1.PolyTyp !== e2.PolyTyp)\n\t\t\t{\n\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t}\n\t\t\telse if (e1Wc === 1 && e2Wc === 1)\n\t\t\t\tswitch (this.m_ClipType)\n\t\t\t\t{\n\t\t\t\tcase ClipperLib.ClipType.ctIntersection:\n\t\t\t\t\tif (e1Wc2 > 0 && e2Wc2 > 0)\n\t\t\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ClipperLib.ClipType.ctUnion:\n\t\t\t\t\tif (e1Wc2 <= 0 && e2Wc2 <= 0)\n\t\t\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ClipperLib.ClipType.ctDifference:\n\t\t\t\t\tif (((e1.PolyTyp === ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n\t\t\t\t\t\t((e1.PolyTyp === ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n\t\t\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ClipperLib.ClipType.ctXor:\n\t\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tClipperLib.Clipper.SwapSides(e1, e2);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n\t{\n\t\tvar SelPrev = e.PrevInSEL;\n\t\tvar SelNext = e.NextInSEL;\n\t\tif (SelPrev === null && SelNext === null && (e !== this.m_SortedEdges))\n\t\t\treturn;\n\t\t//already deleted\n\t\tif (SelPrev !== null)\n\t\t\tSelPrev.NextInSEL = SelNext;\n\t\telse\n\t\t\tthis.m_SortedEdges = SelNext;\n\t\tif (SelNext !== null)\n\t\t\tSelNext.PrevInSEL = SelPrev;\n\t\te.NextInSEL = null;\n\t\te.PrevInSEL = null;\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessHorizontals = function ()\n\t{\n\t\tvar horzEdge = {}; //m_SortedEdges;\n\t\twhile (this.PopEdgeFromSEL(horzEdge))\n\t\t{\n\t\t\tthis.ProcessHorizontal(horzEdge.v);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n\t{\n\t\tif (HorzEdge.Bot.X < HorzEdge.Top.X)\n\t\t{\n\t\t\t$var.Left = HorzEdge.Bot.X;\n\t\t\t$var.Right = HorzEdge.Top.X;\n\t\t\t$var.Dir = ClipperLib.Direction.dLeftToRight;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$var.Left = HorzEdge.Top.X;\n\t\t\t$var.Right = HorzEdge.Bot.X;\n\t\t\t$var.Dir = ClipperLib.Direction.dRightToLeft;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge)\n\t{\n\t\tvar $var = {\n\t\t\tDir: null,\n\t\t\tLeft: null,\n\t\t\tRight: null\n\t\t};\n\n\t\tthis.GetHorzDirection(horzEdge, $var);\n\t\tvar dir = $var.Dir;\n\t\tvar horzLeft = $var.Left;\n\t\tvar horzRight = $var.Right;\n\n\t\tvar IsOpen = horzEdge.WindDelta === 0;\n\n\t\tvar eLastHorz = horzEdge,\n\t\t\teMaxPair = null;\n\t\twhile (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n\t\t\teLastHorz = eLastHorz.NextInLML;\n\t\tif (eLastHorz.NextInLML === null)\n\t\t\teMaxPair = this.GetMaximaPair(eLastHorz);\n\n\t\tvar currMax = this.m_Maxima;\n\t\tif (currMax !== null)\n\t\t{\n\t\t\t//get the first maxima in range (X) ...\n\t\t\tif (dir === ClipperLib.Direction.dLeftToRight)\n\t\t\t{\n\t\t\t\twhile (currMax !== null && currMax.X <= horzEdge.Bot.X)\n\t\t\t\t{\n\t\t\t\t\tcurrMax = currMax.Next;\n\t\t\t\t}\n\t\t\t\tif (currMax !== null && currMax.X >= eLastHorz.Top.X)\n\t\t\t\t{\n\t\t\t\t\tcurrMax = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (currMax.Next !== null && currMax.Next.X < horzEdge.Bot.X)\n\t\t\t\t{\n\t\t\t\t\tcurrMax = currMax.Next;\n\t\t\t\t}\n\t\t\t\tif (currMax.X <= eLastHorz.Top.X)\n\t\t\t\t{\n\t\t\t\t\tcurrMax = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar op1 = null;\n\t\tfor (;;) //loop through consec. horizontal edges\n\t\t{\n\t\t\tvar IsLastHorz = (horzEdge === eLastHorz);\n\t\t\tvar e = this.GetNextInAEL(horzEdge, dir);\n\t\t\twhile (e !== null)\n\t\t\t{\n\t\t\t\t//this code block inserts extra coords into horizontal edges (in output\n\t\t\t\t//polygons) whereever maxima touch these horizontal edges. This helps\n\t\t\t\t//'simplifying' polygons (ie if the Simplify property is set).\n\t\t\t\tif (currMax !== null)\n\t\t\t\t{\n\t\t\t\t\tif (dir === ClipperLib.Direction.dLeftToRight)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile (currMax !== null && currMax.X < e.Curr.X)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (horzEdge.OutIdx >= 0 && !IsOpen)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis.AddOutPt(horzEdge, new ClipperLib.FPoint2(currMax.X, horzEdge.Bot.Y));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrMax = currMax.Next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twhile (currMax !== null && currMax.X > e.Curr.X)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (horzEdge.OutIdx >= 0 && !IsOpen)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis.AddOutPt(horzEdge, new ClipperLib.FPoint2(currMax.X, horzEdge.Bot.Y));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrMax = currMax.Prev;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ((dir === ClipperLib.Direction.dLeftToRight && e.Curr.X > horzRight) || (dir === ClipperLib.Direction.dRightToLeft && e.Curr.X < horzLeft))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//Also break if we've got to the end of an intermediate horizontal edge ...\n\t\t\t\t//nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n\t\t\t\tif (e.Curr.X === horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (horzEdge.OutIdx >= 0 && !IsOpen) //note: may be done multiple times\n\t\t\t\t{\n\t\t\t\t\tif (ClipperLib.use_xyz)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dir === ClipperLib.Direction.dLeftToRight)\n\t\t\t\t\t\t\tthis.SetZ(e.Curr, horzEdge, e);\n\t\t\t\t\t\telse this.SetZ(e.Curr, e, horzEdge);\n\t\t\t\t\t}\n\n\t\t\t\t\top1 = this.AddOutPt(horzEdge, e.Curr);\n\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot.X, horzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar op2 = this.GetLastOutPt(eNextHorz);\n\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t}\n\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t}\n\n\t\t\t\t//OK, so far we're still in range of the horizontal Edge  but make sure\n\t\t\t\t//we're at the last of consec. horizontals when matching with eMaxPair\n\t\t\t\tif (e === eMaxPair && IsLastHorz)\n\t\t\t\t{\n\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t}\n\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (dir === ClipperLib.Direction.dLeftToRight)\n\t\t\t\t{\n\t\t\t\t\tvar Pt = new ClipperLib.FPoint2(e.Curr.X, horzEdge.Curr.Y);\n\t\t\t\t\tthis.IntersectEdges(horzEdge, e, Pt);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar Pt = new ClipperLib.FPoint2(e.Curr.X, horzEdge.Curr.Y);\n\t\t\t\t\tthis.IntersectEdges(e, horzEdge, Pt);\n\t\t\t\t}\n\t\t\t\tvar eNext = this.GetNextInAEL(e, dir);\n\t\t\t\tthis.SwapPositionsInAEL(horzEdge, e);\n\t\t\t\te = eNext;\n\t\t\t} //end while(e !== null)\n\n\t\t\t//Break out of loop if HorzEdge.NextInLML is not also horizontal ...\n\t\t\tif (horzEdge.NextInLML === null || !ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\thorzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(horzEdge, horzEdge.Bot);\n\t\t\t}\n\n\t\t\t$var = {\n\t\t\t\tDir: dir,\n\t\t\t\tLeft: horzLeft,\n\t\t\t\tRight: horzRight\n\t\t\t};\n\n\t\t\tthis.GetHorzDirection(horzEdge, $var);\n\t\t\tdir = $var.Dir;\n\t\t\thorzLeft = $var.Left;\n\t\t\thorzRight = $var.Right;\n\n\t\t} //end for (;;)\n\n\t\tif (horzEdge.OutIdx >= 0 && op1 === null)\n\t\t{\n\t\t\top1 = this.GetLastOutPt(horzEdge);\n\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\twhile (eNextHorz !== null)\n\t\t\t{\n\t\t\t\tif (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot.X, horzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.GetLastOutPt(eNextHorz);\n\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t}\n\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t}\n\t\t\tthis.AddGhostJoin(op1, horzEdge.Top);\n\t\t}\n\n\t\tif (horzEdge.NextInLML !== null)\n\t\t{\n\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t{\n\t\t\t\top1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\n\t\t\t\thorzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t\t\t\tif (horzEdge.WindDelta === 0)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//nb: HorzEdge is no longer horizontal here\n\t\t\t\tvar ePrev = horzEdge.PrevInAEL;\n\t\t\t\tvar eNext = horzEdge.NextInAEL;\n\t\t\t\tif (ePrev !== null && ePrev.Curr.X === horzEdge.Bot.X && ePrev.Curr.Y === horzEdge.Bot.Y && ePrev.WindDelta === 0 && (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y && ClipperLib.ClipperBase.SlopesEqual3(horzEdge, ePrev)))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n\t\t\t\t\tthis.AddJoin(op1, op2, horzEdge.Top);\n\t\t\t\t}\n\t\t\t\telse if (eNext !== null && eNext.Curr.X === horzEdge.Bot.X && eNext.Curr.Y === horzEdge.Bot.Y && eNext.WindDelta !== 0 && eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y && ClipperLib.ClipperBase.SlopesEqual3(horzEdge, eNext))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.AddOutPt(eNext, horzEdge.Bot);\n\t\t\t\t\tthis.AddJoin(op1, op2, horzEdge.Top);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thorzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t}\n\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n\t{\n\t\treturn Direction === ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n\t};\n\n\tClipperLib.Clipper.prototype.IsMinima = function (e)\n\t{\n\t\treturn e !== null && (e.Prev.NextInLML !== e) && (e.Next.NextInLML !== e);\n\t};\n\n\tClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n\t{\n\t\treturn (e !== null && e.Top.Y === Y && e.NextInLML === null);\n\t};\n\n\tClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n\t{\n\t\treturn (e.Top.Y === Y && e.NextInLML !== null);\n\t};\n\n\tClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n\t{\n\t\tif ((ClipperLib.FPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n\t\t{\n\t\t\treturn e.Next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((ClipperLib.FPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n\t\t\t{\n\t\t\t\treturn e.Prev;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetMaximaPairEx = function (e)\n\t{\n\t\t//as above but returns null if MaxPair isn't in AEL (unless it's horizontal)\n\t\tvar result = this.GetMaximaPair(e);\n\t\tif (result === null || result.OutIdx === ClipperLib.ClipperBase.Skip ||\n\t\t\t((result.NextInAEL === result.PrevInAEL) && !ClipperLib.ClipperBase.IsHorizontal(result)))\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n\t{\n\t\tif (this.m_ActiveEdges === null)\n\t\t\treturn true;\n\t\ttry\n\t\t{\n\t\t\tthis.BuildIntersectList(topY);\n\t\t\tif (this.m_IntersectList.length === 0)\n\t\t\t\treturn true;\n\t\t\tif (this.m_IntersectList.length === 1 || this.FixupIntersectionOrder())\n\t\t\t\tthis.ProcessIntersectList();\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\tcatch ($$e2)\n\t\t{\n\t\t\tthis.m_SortedEdges = null;\n\t\t\tthis.m_IntersectList.length = 0;\n\t\t\tClipperLib.Error(\"ProcessIntersections error\");\n\t\t}\n\t\tthis.m_SortedEdges = null;\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n\t{\n\t\tif (this.m_ActiveEdges === null)\n\t\t\treturn;\n\t\t//prepare for sorting ...\n\t\tvar e = this.m_ActiveEdges;\n\t\t//console.log(JSON.stringify(JSON.decycle( e )));\n\t\tthis.m_SortedEdges = e;\n\t\twhile (e !== null)\n\t\t{\n\t\t\te.PrevInSEL = e.PrevInAEL;\n\t\t\te.NextInSEL = e.NextInAEL;\n\t\t\te.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t\t\te = e.NextInAEL;\n\t\t}\n\t\t//bubblesort ...\n\t\tvar isModified = true;\n\t\twhile (isModified && this.m_SortedEdges !== null)\n\t\t{\n\t\t\tisModified = false;\n\t\t\te = this.m_SortedEdges;\n\t\t\twhile (e.NextInSEL !== null)\n\t\t\t{\n\t\t\t\tvar eNext = e.NextInSEL;\n\t\t\t\tvar pt = new ClipperLib.FPoint0();\n\t\t\t\t//console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n\t\t\t\tif (e.Curr.X > eNext.Curr.X)\n\t\t\t\t{\n\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n\t\t\t\t\tif (pt.Y < topY)\n\t\t\t\t\t{\n\t\t\t\t\t\tpt = new ClipperLib.FPoint2(ClipperLib.Clipper.TopX(e, topY), topY);\n\t\t\t\t\t}\n\t\t\t\t\tvar newNode = new ClipperLib.IntersectNode();\n\t\t\t\t\tnewNode.Edge1 = e;\n\t\t\t\t\tnewNode.Edge2 = eNext;\n\t\t\t\t\t//newNode.Pt = pt;\n\t\t\t\t\tnewNode.Pt.X = pt.X;\n\t\t\t\t\tnewNode.Pt.Y = pt.Y;\n\t\t\t\t\tif (ClipperLib.use_xyz) newNode.Pt.Z = pt.Z;\n\t\t\t\t\tthis.m_IntersectList.push(newNode);\n\t\t\t\t\tthis.SwapPositionsInSEL(e, eNext);\n\t\t\t\t\tisModified = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\te = eNext;\n\t\t\t}\n\t\t\tif (e.PrevInSEL !== null)\n\t\t\t\te.PrevInSEL.NextInSEL = null;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.m_SortedEdges = null;\n\t};\n\n\tClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n\t{\n\t\treturn (inode.Edge1.NextInSEL === inode.Edge2) || (inode.Edge1.PrevInSEL === inode.Edge2);\n\t};\n\n\tClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n\t{\n\t\t//the following typecast is safe because the differences in Pt.Y will\n\t\t//be limited to the height of the scanbeam.\n\t\treturn (node2.Pt.Y - node1.Pt.Y);\n\t};\n\n\tClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n\t{\n\t\t//pre-condition: intersections are sorted bottom-most first.\n\t\t//Now it's crucial that intersections are made only between adjacent edges,\n\t\t//so to ensure this the order of intersections may need adjusting ...\n\t\tthis.m_IntersectList.sort(this.m_IntersectNodeComparer);\n\t\tthis.CopyAELToSEL();\n\t\tvar cnt = this.m_IntersectList.length;\n\t\tfor (var i = 0; i < cnt; i++)\n\t\t{\n\t\t\tif (!this.EdgesAdjacent(this.m_IntersectList[i]))\n\t\t\t{\n\t\t\t\tvar j = i + 1;\n\t\t\t\twhile (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n\t\t\t\t\tj++;\n\t\t\t\tif (j === cnt)\n\t\t\t\t\treturn false;\n\t\t\t\tvar tmp = this.m_IntersectList[i];\n\t\t\t\tthis.m_IntersectList[i] = this.m_IntersectList[j];\n\t\t\t\tthis.m_IntersectList[j] = tmp;\n\t\t\t}\n\t\t\tthis.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n\t\t}\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n\t{\n\t\tfor (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n\t\t{\n\t\t\tvar iNode = this.m_IntersectList[i];\n\t\t\tthis.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n\t\t\tthis.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n\t\t}\n\t\tthis.m_IntersectList.length = 0;\n\t};\n\n\tClipperLib.Clipper.TopX = function (edge, currentY)\n\t{\n\t\t//if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n\t\t//if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n\t\tif (currentY === edge.Top.Y)\n\t\t\treturn edge.Top.X;\n\t\treturn edge.Bot.X + edge.Dx * (currentY - edge.Bot.Y);\n\t};\n\n\tClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n\t{\n\t\tip.X = 0;\n\t\tip.Y = 0;\n\t\tvar b1, b2;\n\t\t//nb: with very large coordinate values, it's possible for SlopesEqual() to\n\t\t//return false but for the edge.Dx value be equal due to double precision rounding.\n\t\tif (edge1.Dx === edge2.Dx)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\treturn;\n\t\t}\n\t\tif (edge1.Delta.X === 0)\n\t\t{\n\t\t\tip.X = edge1.Bot.X;\n\t\t\tif (ClipperLib.ClipperBase.IsHorizontal(edge2))\n\t\t\t{\n\t\t\t\tip.Y = edge2.Bot.Y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n\t\t\t\tip.Y = ip.X / edge2.Dx + b2;\n\t\t\t}\n\t\t}\n\t\telse if (edge2.Delta.X === 0)\n\t\t{\n\t\t\tip.X = edge2.Bot.X;\n\t\t\tif (ClipperLib.ClipperBase.IsHorizontal(edge1))\n\t\t\t{\n\t\t\t\tip.Y = edge1.Bot.Y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n\t\t\t\tip.Y = ip.X / edge1.Dx + b1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n\t\t\tb2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n\t\t\tvar q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n\t\t\tip.Y = q;\n\t\t\tif (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t\t\t\tip.X = edge1.Dx * q + b1;\n\t\t\telse\n\t\t\t\tip.X = edge2.Dx * q + b2;\n\t\t}\n\t\tif (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n\t\t{\n\t\t\tif (edge1.Top.Y > edge2.Top.Y)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Top.Y;\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n\t\t\t\treturn ip.X < edge1.Top.X;\n\t\t\t}\n\t\t\telse\n\t\t\t\tip.Y = edge2.Top.Y;\n\t\t\tif (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t}\n\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\tif (ip.Y > edge1.Curr.Y)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n\t{\n\t\tvar e = this.m_ActiveEdges;\n\n\t\twhile (e !== null)\n\t\t{\n\t\t\t//1. process maxima, treating them as if they're 'bent' horizontal edges,\n\t\t\t//   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n\t\t\tvar IsMaximaEdge = this.IsMaxima(e, topY);\n\t\t\tif (IsMaximaEdge)\n\t\t\t{\n\t\t\t\tvar eMaxPair = this.GetMaximaPairEx(e);\n\t\t\t\tIsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n\t\t\t}\n\t\t\tif (IsMaximaEdge)\n\t\t\t{\n\t\t\t\tif (this.StrictlySimple)\n\t\t\t\t{\n\t\t\t\t\tthis.InsertMaxima(e.Top.X);\n\t\t\t\t}\n\t\t\t\tvar ePrev = e.PrevInAEL;\n\t\t\t\tthis.DoMaxima(e);\n\t\t\t\tif (ePrev === null)\n\t\t\t\t\te = this.m_ActiveEdges;\n\t\t\t\telse\n\t\t\t\t\te = ePrev.NextInAEL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n\t\t\t\tif (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n\t\t\t\t{\n\t\t\t\t\te = this.UpdateEdgeIntoAEL(e);\n\t\t\t\t\tif (e.OutIdx >= 0)\n\t\t\t\t\t\tthis.AddOutPt(e, e.Bot);\n\t\t\t\t\tthis.AddEdgeToSEL(e);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\te.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t\t\t\t\te.Curr.Y = topY;\n\t\t\t\t}\n\n\t\t\t\tif (ClipperLib.use_xyz)\n\t\t\t\t{\n\t\t\t\t\tif (e.Top.Y === topY) e.Curr.Z = e.Top.Z;\n\t\t\t\t\telse if (e.Bot.Y === topY) e.Curr.Z = e.Bot.Z;\n\t\t\t\t\telse e.Curr.Z = 0;\n\t\t\t\t}\n\n\t\t\t\t//When StrictlySimple and 'e' is being touched by another edge, then\n\t\t\t\t//make sure both edges have a vertex here ...\n\t\t\t\tif (this.StrictlySimple)\n\t\t\t\t{\n\t\t\t\t\tvar ePrev = e.PrevInAEL;\n\t\t\t\t\tif ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n\t\t\t\t\t\t(ePrev.OutIdx >= 0) && (ePrev.Curr.X === e.Curr.X) &&\n\t\t\t\t\t\t(ePrev.WindDelta !== 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar ip = new ClipperLib.FPoint1(e.Curr);\n\n\t\t\t\t\t\tif (ClipperLib.use_xyz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar op = this.AddOutPt(ePrev, ip);\n\t\t\t\t\t\tvar op2 = this.AddOutPt(e, ip);\n\t\t\t\t\t\tthis.AddJoin(op, op2, ip); //StrictlySimple (type-3) join\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\te = e.NextInAEL;\n\t\t\t}\n\t\t}\n\t\t//3. Process horizontals at the Top of the scanbeam ...\n\t\tthis.ProcessHorizontals();\n\t\tthis.m_Maxima = null;\n\t\t//4. Promote intermediate vertices ...\n\t\te = this.m_ActiveEdges;\n\t\twhile (e !== null)\n\t\t{\n\t\t\tif (this.IsIntermediate(e, topY))\n\t\t\t{\n\t\t\t\tvar op = null;\n\t\t\t\tif (e.OutIdx >= 0)\n\t\t\t\t\top = this.AddOutPt(e, e.Top);\n\t\t\t\te = this.UpdateEdgeIntoAEL(e);\n\t\t\t\t//if output polygons share an edge, they'll need joining later ...\n\t\t\t\tvar ePrev = e.PrevInAEL;\n\t\t\t\tvar eNext = e.NextInAEL;\n\n\t\t\t\tif (ePrev !== null && ePrev.Curr.X === e.Bot.X && ePrev.Curr.Y === e.Bot.Y && op !== null && ePrev.OutIdx >= 0 && ePrev.Curr.Y === ePrev.Top.Y && ClipperLib.ClipperBase.SlopesEqual5(e.Curr, e.Top, ePrev.Curr, ePrev.Top) && (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.AddOutPt(ePrev2, e.Bot);\n\t\t\t\t\tthis.AddJoin(op, op2, e.Top);\n\t\t\t\t}\n\t\t\t\telse if (eNext !== null && eNext.Curr.X === e.Bot.X && eNext.Curr.Y === e.Bot.Y && op !== null && eNext.OutIdx >= 0 && eNext.Curr.Y === eNext.Top.Y && ClipperLib.ClipperBase.SlopesEqual5(e.Curr, e.Top, eNext.Curr, eNext.Top) && (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.AddOutPt(eNext, e.Bot);\n\t\t\t\t\tthis.AddJoin(op, op2, e.Top);\n\t\t\t\t}\n\t\t\t}\n\t\t\te = e.NextInAEL;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.DoMaxima = function (e)\n\t{\n\t\tvar eMaxPair = this.GetMaximaPairEx(e);\n\t\tif (eMaxPair === null)\n\t\t{\n\t\t\tif (e.OutIdx >= 0)\n\t\t\t\tthis.AddOutPt(e, e.Top);\n\t\t\tthis.DeleteFromAEL(e);\n\t\t\treturn;\n\t\t}\n\t\tvar eNext = e.NextInAEL;\n\t\twhile (eNext !== null && eNext !== eMaxPair)\n\t\t{\n\t\t\tthis.IntersectEdges(e, eNext, e.Top);\n\t\t\tthis.SwapPositionsInAEL(e, eNext);\n\t\t\teNext = e.NextInAEL;\n\t\t}\n\t\tif (e.OutIdx === -1 && eMaxPair.OutIdx === -1)\n\t\t{\n\t\t\tthis.DeleteFromAEL(e);\n\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t\t}\n\t\telse if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n\t\t{\n\t\t\tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n\t\t\tthis.DeleteFromAEL(e);\n\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t\t}\n\t\telse if (ClipperLib.use_lines && e.WindDelta === 0)\n\t\t{\n\t\t\tif (e.OutIdx >= 0)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(e, e.Top);\n\t\t\t\te.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t\t\t}\n\t\t\tthis.DeleteFromAEL(e);\n\t\t\tif (eMaxPair.OutIdx >= 0)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(eMaxPair, e.Top);\n\t\t\t\teMaxPair.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t\t\t}\n\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t\t}\n\t\telse\n\t\t\tClipperLib.Error(\"DoMaxima error\");\n\t};\n\n\tClipperLib.Clipper.ReversePaths = function (polys)\n\t{\n\t\tfor (var i = 0, len = polys.length; i < len; i++)\n\t\t\tpolys[i].reverse();\n\t};\n\n\tClipperLib.Clipper.Orientation = function (poly)\n\t{\n\t\treturn ClipperLib.Clipper.Area(poly) >= 0;\n\t};\n\n\tClipperLib.Clipper.prototype.PointCount = function (pts)\n\t{\n\t\tif (pts === null)\n\t\t\treturn 0;\n\t\tvar result = 0;\n\t\tvar p = pts;\n\t\tdo {\n\t\t\tresult++;\n\t\t\tp = p.Next;\n\t\t}\n\t\twhile (p !== pts)\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.BuildResult = function (polyg)\n\t{\n\t\tClipperLib.Clear(polyg);\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts === null)\n\t\t\t\tcontinue;\n\t\t\tvar p = outRec.Pts.Prev;\n\t\t\tvar cnt = this.PointCount(p);\n\t\t\tif (cnt < 2)\n\t\t\t\tcontinue;\n\t\t\tvar pg = new Array(cnt);\n\t\t\tfor (var j = 0; j < cnt; j++)\n\t\t\t{\n\t\t\t\tpg[j] = p.Pt;\n\t\t\t\tp = p.Prev;\n\t\t\t}\n\t\t\tpolyg.push(pg);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n\t{\n\t\tpolytree.Clear();\n\t\t//add each output polygon/contour to polytree ...\n\t\t//polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tvar cnt = this.PointCount(outRec.Pts);\n\t\t\tif ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n\t\t\t\tcontinue;\n\t\t\tthis.FixHoleLinkage(outRec);\n\t\t\tvar pn = new ClipperLib.PolyNode();\n\t\t\tpolytree.m_AllPolys.push(pn);\n\t\t\toutRec.PolyNode = pn;\n\t\t\tpn.m_polygon.length = cnt;\n\t\t\tvar op = outRec.Pts.Prev;\n\t\t\tfor (var j = 0; j < cnt; j++)\n\t\t\t{\n\t\t\t\tpn.m_polygon[j] = op.Pt;\n\t\t\t\top = op.Prev;\n\t\t\t}\n\t\t}\n\t\t//fixup PolyNode links etc ...\n\t\t//polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.PolyNode === null)\n\t\t\t\tcontinue;\n\t\t\telse if (outRec.IsOpen)\n\t\t\t{\n\t\t\t\toutRec.PolyNode.IsOpen = true;\n\t\t\t\tpolytree.AddChild(outRec.PolyNode);\n\t\t\t}\n\t\t\telse if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode !== null)\n\t\t\t\toutRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n\t\t\telse\n\t\t\t\tpolytree.AddChild(outRec.PolyNode);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.FixupOutPolyline = function (outRec)\n\t{\n\t\tvar pp = outRec.Pts;\n\t\tvar lastPP = pp.Prev;\n\t\twhile (pp !== lastPP)\n\t\t{\n\t\t\tpp = pp.Next;\n\t\t\tif (ClipperLib.FPoint.op_Equality(pp.Pt, pp.Prev.Pt))\n\t\t\t{\n\t\t\t\tif (pp === lastPP)\n\t\t\t\t{\n\t\t\t\t\tlastPP = pp.Prev;\n\t\t\t\t}\n\t\t\t\tvar tmpPP = pp.Prev;\n\t\t\t\ttmpPP.Next = pp.Next;\n\t\t\t\tpp.Next.Prev = tmpPP;\n\t\t\t\tpp = tmpPP;\n\t\t\t}\n\t\t}\n\t\tif (pp === pp.Prev)\n\t\t{\n\t\t\toutRec.Pts = null;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n\t{\n\t\t//FixupOutPolygon() - removes duplicate points and simplifies consecutive\n\t\t//parallel edges by removing the middle vertex.\n\t\tvar lastOK = null;\n\t\toutRec.BottomPt = null;\n\t\tvar pp = outRec.Pts;\n\t\tvar preserveCol = this.PreserveCollinear || this.StrictlySimple;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (pp.Prev === pp || pp.Prev === pp.Next)\n\t\t\t{\n\t\t\t\toutRec.Pts = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//test for duplicate points and collinear edges ...\n\t\t\tif ((ClipperLib.FPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.FPoint.op_Equality(pp.Pt, pp.Prev.Pt)) || (ClipperLib.ClipperBase.SlopesEqual4(pp.Prev.Pt, pp.Pt, pp.Next.Pt) && (!preserveCol || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n\t\t\t{\n\t\t\t\tlastOK = null;\n\t\t\t\tpp.Prev.Next = pp.Next;\n\t\t\t\tpp.Next.Prev = pp.Prev;\n\t\t\t\tpp = pp.Prev;\n\t\t\t}\n\t\t\telse if (pp === lastOK)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (lastOK === null)\n\t\t\t\t\tlastOK = pp;\n\t\t\t\tpp = pp.Next;\n\t\t\t}\n\t\t}\n\t\toutRec.Pts = pp;\n\t};\n\n\tClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n\t{\n\t\tvar result = new ClipperLib.OutPt();\n\t\t//result.Pt = outPt.Pt;\n\t\tresult.Pt.X = outPt.Pt.X;\n\t\tresult.Pt.Y = outPt.Pt.Y;\n\t\tif (ClipperLib.use_xyz) result.Pt.Z = outPt.Pt.Z;\n\t\tresult.Idx = outPt.Idx;\n\t\tif (InsertAfter)\n\t\t{\n\t\t\tresult.Next = outPt.Next;\n\t\t\tresult.Prev = outPt;\n\t\t\toutPt.Next.Prev = result;\n\t\t\toutPt.Next = result;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.Prev = outPt.Prev;\n\t\t\tresult.Next = outPt;\n\t\t\toutPt.Prev.Next = result;\n\t\t\toutPt.Prev = result;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n\t{\n\t\tif (a1 < a2)\n\t\t{\n\t\t\tif (b1 < b2)\n\t\t\t{\n\t\t\t\t$val.Left = Math.max(a1, b1);\n\t\t\t\t$val.Right = Math.min(a2, b2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$val.Left = Math.max(a1, b2);\n\t\t\t\t$val.Right = Math.min(a2, b1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (b1 < b2)\n\t\t\t{\n\t\t\t\t$val.Left = Math.max(a2, b1);\n\t\t\t\t$val.Right = Math.min(a1, b2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$val.Left = Math.max(a2, b2);\n\t\t\t\t$val.Right = Math.min(a1, b1);\n\t\t\t}\n\t\t}\n\t\treturn $val.Left < $val.Right;\n\t};\n\n\tClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n\t{\n\t\tvar Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t\tvar Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t\tif (Dir1 === Dir2)\n\t\t\treturn false;\n\t\t//When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n\t\t//want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n\t\t//So, to facilitate this while inserting Op1b and Op2b ...\n\t\t//when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n\t\t//otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n\t\tif (Dir1 === ClipperLib.Direction.dLeftToRight)\n\t\t{\n\t\t\twhile (op1.Next.Pt.X <= Pt.X &&\n\t\t\t\top1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y === Pt.Y)\n\t\t\t\top1 = op1.Next;\n\t\t\tif (DiscardLeft && (op1.Pt.X !== Pt.X))\n\t\t\t\top1 = op1.Next;\n\t\t\top1b = this.DupOutPt(op1, !DiscardLeft);\n\t\t\tif (ClipperLib.FPoint.op_Inequality(op1b.Pt, Pt))\n\t\t\t{\n\t\t\t\top1 = op1b;\n\t\t\t\t//op1.Pt = Pt;\n\t\t\t\top1.Pt.X = Pt.X;\n\t\t\t\top1.Pt.Y = Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) op1.Pt.Z = Pt.Z;\n\t\t\t\top1b = this.DupOutPt(op1, !DiscardLeft);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (op1.Next.Pt.X >= Pt.X &&\n\t\t\t\top1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y === Pt.Y)\n\t\t\t\top1 = op1.Next;\n\t\t\tif (!DiscardLeft && (op1.Pt.X !== Pt.X))\n\t\t\t\top1 = op1.Next;\n\t\t\top1b = this.DupOutPt(op1, DiscardLeft);\n\t\t\tif (ClipperLib.FPoint.op_Inequality(op1b.Pt, Pt))\n\t\t\t{\n\t\t\t\top1 = op1b;\n\t\t\t\t//op1.Pt = Pt;\n\t\t\t\top1.Pt.X = Pt.X;\n\t\t\t\top1.Pt.Y = Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) op1.Pt.Z = Pt.Z;\n\t\t\t\top1b = this.DupOutPt(op1, DiscardLeft);\n\t\t\t}\n\t\t}\n\t\tif (Dir2 === ClipperLib.Direction.dLeftToRight)\n\t\t{\n\t\t\twhile (op2.Next.Pt.X <= Pt.X &&\n\t\t\t\top2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y === Pt.Y)\n\t\t\t\top2 = op2.Next;\n\t\t\tif (DiscardLeft && (op2.Pt.X !== Pt.X))\n\t\t\t\top2 = op2.Next;\n\t\t\top2b = this.DupOutPt(op2, !DiscardLeft);\n\t\t\tif (ClipperLib.FPoint.op_Inequality(op2b.Pt, Pt))\n\t\t\t{\n\t\t\t\top2 = op2b;\n\t\t\t\t//op2.Pt = Pt;\n\t\t\t\top2.Pt.X = Pt.X;\n\t\t\t\top2.Pt.Y = Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) op2.Pt.Z = Pt.Z;\n\t\t\t\top2b = this.DupOutPt(op2, !DiscardLeft);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (op2.Next.Pt.X >= Pt.X &&\n\t\t\t\top2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y === Pt.Y)\n\t\t\t\top2 = op2.Next;\n\t\t\tif (!DiscardLeft && (op2.Pt.X !== Pt.X))\n\t\t\t\top2 = op2.Next;\n\t\t\top2b = this.DupOutPt(op2, DiscardLeft);\n\t\t\tif (ClipperLib.FPoint.op_Inequality(op2b.Pt, Pt))\n\t\t\t{\n\t\t\t\top2 = op2b;\n\t\t\t\t//op2.Pt = Pt;\n\t\t\t\top2.Pt.X = Pt.X;\n\t\t\t\top2.Pt.Y = Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) op2.Pt.Z = Pt.Z;\n\t\t\t\top2b = this.DupOutPt(op2, DiscardLeft);\n\t\t\t}\n\t\t}\n\t\tif ((Dir1 === ClipperLib.Direction.dLeftToRight) === DiscardLeft)\n\t\t{\n\t\t\top1.Prev = op2;\n\t\t\top2.Next = op1;\n\t\t\top1b.Next = op2b;\n\t\t\top2b.Prev = op1b;\n\t\t}\n\t\telse\n\t\t{\n\t\t\top1.Next = op2;\n\t\t\top2.Prev = op1;\n\t\t\top1b.Prev = op2b;\n\t\t\top2b.Next = op1b;\n\t\t}\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n\t{\n\t\tvar op1 = j.OutPt1,\n\t\t\top1b = new ClipperLib.OutPt();\n\t\tvar op2 = j.OutPt2,\n\t\t\top2b = new ClipperLib.OutPt();\n\t\t//There are 3 kinds of joins for output polygons ...\n\t\t//1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are vertices anywhere\n\t\t//along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n\t\t//2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n\t\t//location at the Bottom of the overlapping segment (& Join.OffPt is above).\n\t\t//3. StrictlySimple joins where edges touch but are not collinear and where\n\t\t//Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n\t\tvar isHorizontal = (j.OutPt1.Pt.Y === j.OffPt.Y);\n\t\tif (isHorizontal && (ClipperLib.FPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.FPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n\t\t{\n\t\t\t//Strictly Simple join ...\n\t\t\tif (outRec1 !== outRec2) return false;\n\n\t\t\top1b = j.OutPt1.Next;\n\t\t\twhile (op1b !== op1 && (ClipperLib.FPoint.op_Equality(op1b.Pt, j.OffPt)))\n\t\t\t\top1b = op1b.Next;\n\t\t\tvar reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n\t\t\top2b = j.OutPt2.Next;\n\t\t\twhile (op2b !== op2 && (ClipperLib.FPoint.op_Equality(op2b.Pt, j.OffPt)))\n\t\t\t\top2b = op2b.Next;\n\t\t\tvar reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n\t\t\tif (reverse1 === reverse2)\n\t\t\t\treturn false;\n\t\t\tif (reverse1)\n\t\t\t{\n\t\t\t\top1b = this.DupOutPt(op1, false);\n\t\t\t\top2b = this.DupOutPt(op2, true);\n\t\t\t\top1.Prev = op2;\n\t\t\t\top2.Next = op1;\n\t\t\t\top1b.Next = op2b;\n\t\t\t\top2b.Prev = op1b;\n\t\t\t\tj.OutPt1 = op1;\n\t\t\t\tj.OutPt2 = op1b;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\top1b = this.DupOutPt(op1, true);\n\t\t\t\top2b = this.DupOutPt(op2, false);\n\t\t\t\top1.Next = op2;\n\t\t\t\top2.Prev = op1;\n\t\t\t\top1b.Prev = op2b;\n\t\t\t\top2b.Next = op1b;\n\t\t\t\tj.OutPt1 = op1;\n\t\t\t\tj.OutPt2 = op1b;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (isHorizontal)\n\t\t{\n\t\t\t//treat horizontal joins differently to non-horizontal joins since with\n\t\t\t//them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n\t\t\t//may be anywhere along the horizontal edge.\n\t\t\top1b = op1;\n\t\t\twhile (op1.Prev.Pt.Y === op1.Pt.Y && op1.Prev !== op1b && op1.Prev !== op2)\n\t\t\t\top1 = op1.Prev;\n\t\t\twhile (op1b.Next.Pt.Y === op1b.Pt.Y && op1b.Next !== op1 && op1b.Next !== op2)\n\t\t\t\top1b = op1b.Next;\n\t\t\tif (op1b.Next === op1 || op1b.Next === op2)\n\t\t\t\treturn false;\n\t\t\t//a flat 'polygon'\n\t\t\top2b = op2;\n\t\t\twhile (op2.Prev.Pt.Y === op2.Pt.Y && op2.Prev !== op2b && op2.Prev !== op1b)\n\t\t\t\top2 = op2.Prev;\n\t\t\twhile (op2b.Next.Pt.Y === op2b.Pt.Y && op2b.Next !== op2 && op2b.Next !== op1)\n\t\t\t\top2b = op2b.Next;\n\t\t\tif (op2b.Next === op2 || op2b.Next === op1)\n\t\t\t\treturn false;\n\t\t\t//a flat 'polygon'\n\t\t\t//Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n\t\t\tvar $val = {\n\t\t\t\tLeft: null,\n\t\t\t\tRight: null\n\t\t\t};\n\n\t\t\tif (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n\t\t\t\treturn false;\n\t\t\tvar Left = $val.Left;\n\t\t\tvar Right = $val.Right;\n\n\t\t\t//DiscardLeftSide: when overlapping edges are joined, a spike will created\n\t\t\t//which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n\t\t\t//on the discard Side as either may still be needed for other joins ...\n\t\t\tvar Pt = new ClipperLib.FPoint0();\n\t\t\tvar DiscardLeftSide;\n\t\t\tif (op1.Pt.X >= Left && op1.Pt.X <= Right)\n\t\t\t{\n\t\t\t\t//Pt = op1.Pt;\n\t\t\t\tPt.X = op1.Pt.X;\n\t\t\t\tPt.Y = op1.Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) Pt.Z = op1.Pt.Z;\n\t\t\t\tDiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n\t\t\t}\n\t\t\telse if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n\t\t\t{\n\t\t\t\t//Pt = op2.Pt;\n\t\t\t\tPt.X = op2.Pt.X;\n\t\t\t\tPt.Y = op2.Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) Pt.Z = op2.Pt.Z;\n\t\t\t\tDiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n\t\t\t}\n\t\t\telse if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n\t\t\t{\n\t\t\t\t//Pt = op1b.Pt;\n\t\t\t\tPt.X = op1b.Pt.X;\n\t\t\t\tPt.Y = op1b.Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) Pt.Z = op1b.Pt.Z;\n\t\t\t\tDiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Pt = op2b.Pt;\n\t\t\t\tPt.X = op2b.Pt.X;\n\t\t\t\tPt.Y = op2b.Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) Pt.Z = op2b.Pt.Z;\n\t\t\t\tDiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n\t\t\t}\n\t\t\tj.OutPt1 = op1;\n\t\t\tj.OutPt2 = op2;\n\t\t\treturn this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//nb: For non-horizontal joins ...\n\t\t\t//    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n\t\t\t//    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n\t\t\t//make sure the polygons are correctly oriented ...\n\t\t\top1b = op1.Next;\n\t\t\twhile ((ClipperLib.FPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b !== op1))\n\t\t\t\top1b = op1b.Next;\n\t\t\tvar Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op1.Pt, op1b.Pt, j.OffPt));\n\t\t\tif (Reverse1)\n\t\t\t{\n\t\t\t\top1b = op1.Prev;\n\t\t\t\twhile ((ClipperLib.FPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b !== op1))\n\t\t\t\t\top1b = op1b.Prev;\n\n\t\t\t\tif ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op1.Pt, op1b.Pt, j.OffPt))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\top2b = op2.Next;\n\t\t\twhile ((ClipperLib.FPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b !== op2))\n\t\t\t\top2b = op2b.Next;\n\n\t\t\tvar Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op2.Pt, op2b.Pt, j.OffPt));\n\t\t\tif (Reverse2)\n\t\t\t{\n\t\t\t\top2b = op2.Prev;\n\t\t\t\twhile ((ClipperLib.FPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b !== op2))\n\t\t\t\t\top2b = op2b.Prev;\n\n\t\t\t\tif ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op2.Pt, op2b.Pt, j.OffPt))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ((op1b === op1) || (op2b === op2) || (op1b === op2b) ||\n\t\t\t\t((outRec1 === outRec2) && (Reverse1 === Reverse2)))\n\t\t\t\treturn false;\n\t\t\tif (Reverse1)\n\t\t\t{\n\t\t\t\top1b = this.DupOutPt(op1, false);\n\t\t\t\top2b = this.DupOutPt(op2, true);\n\t\t\t\top1.Prev = op2;\n\t\t\t\top2.Next = op1;\n\t\t\t\top1b.Next = op2b;\n\t\t\t\top2b.Prev = op1b;\n\t\t\t\tj.OutPt1 = op1;\n\t\t\t\tj.OutPt2 = op1b;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\top1b = this.DupOutPt(op1, true);\n\t\t\t\top2b = this.DupOutPt(op2, false);\n\t\t\t\top1.Next = op2;\n\t\t\t\top2.Prev = op1;\n\t\t\t\top1b.Prev = op2b;\n\t\t\t\top2b.Next = op1b;\n\t\t\t\tj.OutPt1 = op1;\n\t\t\t\tj.OutPt2 = op1b;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.GetBounds = function (paths)\n\t{\n\t\tvar i = 0,\n\t\t\tcnt = paths.length;\n\t\twhile (i < cnt && paths[i].length === 0) i++;\n\t\tif (i === cnt) return new ClipperLib.FRect(0, 0, 0, 0);\n\t\tvar result = new ClipperLib.FRect();\n\t\tresult.left = paths[i][0].X;\n\t\tresult.right = result.left;\n\t\tresult.top = paths[i][0].Y;\n\t\tresult.bottom = result.top;\n\t\tfor (; i < cnt; i++)\n\t\t\tfor (var j = 0, jlen = paths[i].length; j < jlen; j++)\n\t\t\t{\n\t\t\t\tif (paths[i][j].X < result.left) result.left = paths[i][j].X;\n\t\t\t\telse if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n\t\t\t\tif (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n\t\t\t\telse if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n\t\t\t}\n\t\treturn result;\n\t}\n\tClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n\t{\n\t\tvar opStart = ops;\n\t\tvar result = new ClipperLib.FRect();\n\t\tresult.left = ops.Pt.X;\n\t\tresult.right = ops.Pt.X;\n\t\tresult.top = ops.Pt.Y;\n\t\tresult.bottom = ops.Pt.Y;\n\t\tops = ops.Next;\n\t\twhile (ops !== opStart)\n\t\t{\n\t\t\tif (ops.Pt.X < result.left)\n\t\t\t\tresult.left = ops.Pt.X;\n\t\t\tif (ops.Pt.X > result.right)\n\t\t\t\tresult.right = ops.Pt.X;\n\t\t\tif (ops.Pt.Y < result.top)\n\t\t\t\tresult.top = ops.Pt.Y;\n\t\t\tif (ops.Pt.Y > result.bottom)\n\t\t\t\tresult.bottom = ops.Pt.Y;\n\t\t\tops = ops.Next;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.PointInPolygon = function (pt, path)\n\t{\n\t\t//returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t\t//http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t\tvar result = 0,\n\t\t\tcnt = path.length;\n\t\tif (cnt < 3)\n\t\t\treturn 0;\n\t\tvar ip = path[0];\n\t\tfor (var i = 1; i <= cnt; ++i)\n\t\t{\n\t\t\tvar ipNext = (i === cnt ? path[0] : path[i]);\n\t\t\tif (ipNext.Y === pt.Y)\n\t\t\t{\n\t\t\t\tif ((ipNext.X === pt.X) || (ip.Y === pt.Y && ((ipNext.X > pt.X) === (ip.X < pt.X))))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((ip.Y < pt.Y) !== (ipNext.Y < pt.Y))\n\t\t\t{\n\t\t\t\tif (ip.X >= pt.X)\n\t\t\t\t{\n\t\t\t\t\tif (ipNext.X > pt.X)\n\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t\t\t\t\t\tif (d === 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\telse if ((d > 0) === (ipNext.Y > ip.Y))\n\t\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (ipNext.X > pt.X)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t\t\t\t\t\tif (d === 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\telse if ((d > 0) === (ipNext.Y > ip.Y))\n\t\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tip = ipNext;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n\t{\n\t\t//returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\tvar result = 0;\n\t\tvar startOp = op;\n\t\tvar ptx = pt.X,\n\t\t\tpty = pt.Y;\n\t\tvar poly0x = op.Pt.X,\n\t\t\tpoly0y = op.Pt.Y;\n\t\tdo {\n\t\t\top = op.Next;\n\t\t\tvar poly1x = op.Pt.X,\n\t\t\t\tpoly1y = op.Pt.Y;\n\t\t\tif (poly1y === pty)\n\t\t\t{\n\t\t\t\tif ((poly1x === ptx) || (poly0y === pty && ((poly1x > ptx) === (poly0x < ptx))))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((poly0y < pty) !== (poly1y < pty))\n\t\t\t{\n\t\t\t\tif (poly0x >= ptx)\n\t\t\t\t{\n\t\t\t\t\tif (poly1x > ptx)\n\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t\t\t\t\t\tif (d === 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tif ((d > 0) === (poly1y > poly0y))\n\t\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (poly1x > ptx)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t\t\t\t\t\tif (d === 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tif ((d > 0) === (poly1y > poly0y))\n\t\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpoly0x = poly1x;\n\t\t\tpoly0y = poly1y;\n\t\t} while (startOp !== op);\n\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n\t{\n\t\tvar op = outPt1;\n\t\tdo {\n\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n\t\t\tvar res = this.PointInPolygon(op.Pt, outPt2);\n\t\t\tif (res >= 0)\n\t\t\t\treturn res > 0;\n\t\t\top = op.Next;\n\t\t}\n\t\twhile (op !== outPt1)\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n\t{\n\t\tvar outRec, firstLeft;\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\tfirstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (outRec.Pts !== null && firstLeft === OldOutRec)\n\t\t\t{\n\t\t\t\tif (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n\t\t\t\t\toutRec.FirstLeft = NewOutRec;\n\t\t\t}\n\t\t}\n\t}\n\n\tClipperLib.Clipper.prototype.FixupFirstLefts2 = function (innerOutRec, outerOutRec)\n\t{\n\t\t//A polygon has split into two such that one is now the inner of the other.\n\t\t//It's possible that these polygons now wrap around other polygons, so check\n\t\t//every polygon that's also contained by OuterOutRec's FirstLeft container\n\t\t//(including nil) to see if they've become inner to the new inner polygon ...\n\t\tvar orfl = outerOutRec.FirstLeft;\n\t\tvar outRec, firstLeft;\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts === null || outRec === outerOutRec || outRec === innerOutRec)\n\t\t\t\tcontinue;\n\t\t\tfirstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (firstLeft !== orfl && firstLeft !== innerOutRec && firstLeft !== outerOutRec)\n\t\t\t\tcontinue;\n\t\t\tif (this.Poly2ContainsPoly1(outRec.Pts, innerOutRec.Pts))\n\t\t\t\toutRec.FirstLeft = innerOutRec;\n\t\t\telse if (this.Poly2ContainsPoly1(outRec.Pts, outerOutRec.Pts))\n\t\t\t\toutRec.FirstLeft = outerOutRec;\n\t\t\telse if (outRec.FirstLeft === innerOutRec || outRec.FirstLeft === outerOutRec)\n\t\t\t\toutRec.FirstLeft = orfl;\n\t\t}\n\t}\n\n\tClipperLib.Clipper.prototype.FixupFirstLefts3 = function (OldOutRec, NewOutRec)\n\t{\n\t\t//same as FixupFirstLefts1 but doesn't call Poly2ContainsPoly1()\n\t\tvar outRec;\n\t\tvar firstLeft;\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\tfirstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (outRec.Pts !== null && firstLeft === OldOutRec)\n\t\t\t\toutRec.FirstLeft = NewOutRec;\n\t\t}\n\t}\n\n\tClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n\t{\n\t\twhile (FirstLeft !== null && FirstLeft.Pts === null)\n\t\t\tFirstLeft = FirstLeft.FirstLeft;\n\t\treturn FirstLeft;\n\t};\n\n\tClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n\t{\n\t\tfor (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n\t\t{\n\t\t\tvar join = this.m_Joins[i];\n\t\t\tvar outRec1 = this.GetOutRec(join.OutPt1.Idx);\n\t\t\tvar outRec2 = this.GetOutRec(join.OutPt2.Idx);\n\t\t\tif (outRec1.Pts === null || outRec2.Pts === null)\n\t\t\t\tcontinue;\n\n\t\t\tif (outRec1.IsOpen || outRec2.IsOpen)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//get the polygon fragment with the correct hole state (FirstLeft)\n\t\t\t//before calling JoinPoints() ...\n\t\t\tvar holeStateRec;\n\t\t\tif (outRec1 === outRec2)\n\t\t\t\tholeStateRec = outRec1;\n\t\t\telse if (this.OutRec1RightOfOutRec2(outRec1, outRec2))\n\t\t\t\tholeStateRec = outRec2;\n\t\t\telse if (this.OutRec1RightOfOutRec2(outRec2, outRec1))\n\t\t\t\tholeStateRec = outRec1;\n\t\t\telse\n\t\t\t\tholeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n\t\t\tif (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n\t\t\tif (outRec1 === outRec2)\n\t\t\t{\n\t\t\t\t//instead of joining two polygons, we've just created a new one by\n\t\t\t\t//splitting one polygon into two.\n\t\t\t\toutRec1.Pts = join.OutPt1;\n\t\t\t\toutRec1.BottomPt = null;\n\t\t\t\toutRec2 = this.CreateOutRec();\n\t\t\t\toutRec2.Pts = join.OutPt2;\n\t\t\t\t//update all OutRec2.Pts Idx's ...\n\t\t\t\tthis.UpdateOutPtIdxs(outRec2);\n\n\t\t\t\tif (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n\t\t\t\t{\n\t\t\t\t\t//outRec1 contains outRec2 ...\n\t\t\t\t\toutRec2.IsHole = !outRec1.IsHole;\n\t\t\t\t\toutRec2.FirstLeft = outRec1;\n\t\t\t\t\tif (this.m_UsingPolyTree)\n\t\t\t\t\t\tthis.FixupFirstLefts2(outRec2, outRec1);\n\t\t\t\t\tif ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec2) > 0))\n\t\t\t\t\t\tthis.ReversePolyPtLinks(outRec2.Pts);\n\t\t\t\t}\n\t\t\t\telse if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n\t\t\t\t{\n\t\t\t\t\t//outRec2 contains outRec1 ...\n\t\t\t\t\toutRec2.IsHole = outRec1.IsHole;\n\t\t\t\t\toutRec1.IsHole = !outRec2.IsHole;\n\t\t\t\t\toutRec2.FirstLeft = outRec1.FirstLeft;\n\t\t\t\t\toutRec1.FirstLeft = outRec2;\n\t\t\t\t\tif (this.m_UsingPolyTree)\n\t\t\t\t\t\tthis.FixupFirstLefts2(outRec1, outRec2);\n\n\t\t\t\t\tif ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec1) > 0))\n\t\t\t\t\t\tthis.ReversePolyPtLinks(outRec1.Pts);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//the 2 polygons are completely separate ...\n\t\t\t\t\toutRec2.IsHole = outRec1.IsHole;\n\t\t\t\t\toutRec2.FirstLeft = outRec1.FirstLeft;\n\t\t\t\t\t//fixup FirstLeft pointers that may need reassigning to OutRec2\n\t\t\t\t\tif (this.m_UsingPolyTree)\n\t\t\t\t\t\tthis.FixupFirstLefts1(outRec1, outRec2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//joined 2 polygons together ...\n\t\t\t\toutRec2.Pts = null;\n\t\t\t\toutRec2.BottomPt = null;\n\t\t\t\toutRec2.Idx = outRec1.Idx;\n\t\t\t\toutRec1.IsHole = holeStateRec.IsHole;\n\t\t\t\tif (holeStateRec === outRec2)\n\t\t\t\t\toutRec1.FirstLeft = outRec2.FirstLeft;\n\t\t\t\toutRec2.FirstLeft = outRec1;\n\t\t\t\t//fixup FirstLeft pointers that may need reassigning to OutRec1\n\t\t\t\tif (this.m_UsingPolyTree)\n\t\t\t\t\tthis.FixupFirstLefts3(outRec2, outRec1);\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n\t{\n\t\tvar op = outrec.Pts;\n\t\tdo {\n\t\t\top.Idx = outrec.Idx;\n\t\t\top = op.Prev;\n\t\t}\n\t\twhile (op !== outrec.Pts)\n\t};\n\n\tClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n\t{\n\t\tvar i = 0;\n\t\twhile (i < this.m_PolyOuts.length)\n\t\t{\n\t\t\tvar outrec = this.m_PolyOuts[i++];\n\t\t\tvar op = outrec.Pts;\n\t\t\tif (op === null || outrec.IsOpen)\n\t\t\t\tcontinue;\n\t\t\tdo //for each Pt in Polygon until duplicate found do ...\n\t\t\t{\n\t\t\t\tvar op2 = op.Next;\n\t\t\t\twhile (op2 !== outrec.Pts)\n\t\t\t\t{\n\t\t\t\t\tif ((ClipperLib.FPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next !== op && op2.Prev !== op)\n\t\t\t\t\t{\n\t\t\t\t\t\t//split the polygon into two ...\n\t\t\t\t\t\tvar op3 = op.Prev;\n\t\t\t\t\t\tvar op4 = op2.Prev;\n\t\t\t\t\t\top.Prev = op4;\n\t\t\t\t\t\top4.Next = op;\n\t\t\t\t\t\top2.Prev = op3;\n\t\t\t\t\t\top3.Next = op2;\n\t\t\t\t\t\toutrec.Pts = op;\n\t\t\t\t\t\tvar outrec2 = this.CreateOutRec();\n\t\t\t\t\t\toutrec2.Pts = op2;\n\t\t\t\t\t\tthis.UpdateOutPtIdxs(outrec2);\n\t\t\t\t\t\tif (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//OutRec2 is contained by OutRec1 ...\n\t\t\t\t\t\t\toutrec2.IsHole = !outrec.IsHole;\n\t\t\t\t\t\t\toutrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//OutRec1 is contained by OutRec2 ...\n\t\t\t\t\t\t\toutrec2.IsHole = outrec.IsHole;\n\t\t\t\t\t\t\toutrec.IsHole = !outrec2.IsHole;\n\t\t\t\t\t\t\toutrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\toutrec.FirstLeft = outrec2;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//the 2 polygons are separate ...\n\t\t\t\t\t\t\toutrec2.IsHole = outrec.IsHole;\n\t\t\t\t\t\t\toutrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\top2 = op;\n\t\t\t\t\t\t//ie get ready for the next iteration\n\t\t\t\t\t}\n\t\t\t\t\top2 = op2.Next;\n\t\t\t\t}\n\t\t\t\top = op.Next;\n\t\t\t}\n\t\t\twhile (op !== outrec.Pts)\n\t\t}\n\t};\n\n\tClipperLib.Clipper.Area = function (poly)\n\t{\n\t\tif (!Array.isArray(poly))\n\t\t\treturn 0;\n\t\tvar cnt = poly.length;\n\t\tif (cnt < 3)\n\t\t\treturn 0;\n\t\tvar a = 0;\n\t\tfor (var i = 0, j = cnt - 1; i < cnt; ++i)\n\t\t{\n\t\t\ta += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n\t\t\tj = i;\n\t\t}\n\t\treturn -a * 0.5;\n\t};\n\n\tClipperLib.Clipper.prototype.Area = function (op)\n\t{\n\t\tvar opFirst = op;\n\t\tif (op === null) return 0;\n\t\tvar a = 0;\n\t\tdo {\n\t\t\ta = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n\t\t\top = op.Next;\n\t\t} while (op !== opFirst); // && typeof op !== 'undefined');\n\t\treturn a * 0.5;\n\t}\n\n\tClipperLib.Clipper.prototype.Area$1 = function (outRec)\n\t{\n\t\treturn this.Area(outRec.Pts);\n\t};\n\n\tClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n\t{\n\t\tvar result = new Array();\n\t\tvar c = new ClipperLib.Clipper(0);\n\t\tc.StrictlySimple = true;\n\t\tc.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n\t{\n\t\tif (typeof (fillType) === \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t\tvar result = new Array();\n\t\tvar c = new ClipperLib.Clipper(0);\n\t\tc.StrictlySimple = true;\n\t\tc.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n\t{\n\t\tvar dx = (pt1.X - pt2.X);\n\t\tvar dy = (pt1.Y - pt2.Y);\n\t\treturn (dx * dx + dy * dy);\n\t};\n\n\tClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n\t{\n\t\t//The equation of a line in general form (Ax + By + C = 0)\n\t\t//given 2 points (x,y) & (x,y) is ...\n\t\t//(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n\t\t//A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n\t\t//perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n\t\t//see http://en.wikipedia.org/wiki/Perpendicular_distance\n\t\tvar A = ln1.Y - ln2.Y;\n\t\tvar B = ln2.X - ln1.X;\n\t\tvar C = A * ln1.X + B * ln1.Y;\n\t\tC = A * pt.X + B * pt.Y - C;\n\t\treturn (C * C) / (A * A + B * B);\n\t};\n\n\tClipperLib.Clipper.SlopesNearCollinear = function (pt1, pt2, pt3, distSqrd)\n\t{\n\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t//between the other 2 points is the one that's tested for distance.\n\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t{\n\t\t\tif ((pt1.X > pt2.X) === (pt1.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.X > pt1.X) === (pt2.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((pt1.Y > pt2.Y) === (pt1.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.Y > pt1.Y) === (pt2.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t}\n\n\tClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n\t{\n\t\tvar dx = pt1.X - pt2.X;\n\t\tvar dy = pt1.Y - pt2.Y;\n\t\treturn ((dx * dx) + (dy * dy) <= distSqrd);\n\t};\n\n\tClipperLib.Clipper.ExcludeOp = function (op)\n\t{\n\t\tvar result = op.Prev;\n\t\tresult.Next = op.Next;\n\t\top.Next.Prev = result;\n\t\tresult.Idx = 0;\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.CleanPolygon = function (path, distance)\n\t{\n\t\tif (typeof (distance) === \"undefined\") distance = 1.415;\n\t\t//distance = proximity in units/pixels below which vertices will be stripped.\n\t\t//Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n\t\t//both x & y coords within 1 unit, then the second vertex will be stripped.\n\t\tvar cnt = path.length;\n\t\tif (cnt === 0)\n\t\t\treturn new Array();\n\t\tvar outPts = new Array(cnt);\n\t\tfor (var i = 0; i < cnt; ++i)\n\t\t\toutPts[i] = new ClipperLib.OutPt();\n\t\tfor (var i = 0; i < cnt; ++i)\n\t\t{\n\t\t\toutPts[i].Pt = path[i];\n\t\t\toutPts[i].Next = outPts[(i + 1) % cnt];\n\t\t\toutPts[i].Next.Prev = outPts[i];\n\t\t\toutPts[i].Idx = 0;\n\t\t}\n\t\tvar distSqrd = distance * distance;\n\t\tvar op = outPts[0];\n\t\twhile (op.Idx === 0 && op.Next !== op.Prev)\n\t\t{\n\t\t\tif (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n\t\t\t{\n\t\t\t\top = ClipperLib.Clipper.ExcludeOp(op);\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\telse if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n\t\t\t{\n\t\t\t\tClipperLib.Clipper.ExcludeOp(op.Next);\n\t\t\t\top = ClipperLib.Clipper.ExcludeOp(op);\n\t\t\t\tcnt -= 2;\n\t\t\t}\n\t\t\telse if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n\t\t\t{\n\t\t\t\top = ClipperLib.Clipper.ExcludeOp(op);\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\top.Idx = 1;\n\t\t\t\top = op.Next;\n\t\t\t}\n\t\t}\n\t\tif (cnt < 3)\n\t\t\tcnt = 0;\n\t\tvar result = new Array(cnt);\n\t\tfor (var i = 0; i < cnt; ++i)\n\t\t{\n\t\t\tresult[i] = new ClipperLib.FPoint1(op.Pt);\n\t\t\top = op.Next;\n\t\t}\n\t\toutPts = null;\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.CleanPolygons = function (polys, distance)\n\t{\n\t\tvar result = new Array(polys.length);\n\t\tfor (var i = 0, ilen = polys.length; i < ilen; i++)\n\t\t\tresult[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n\t{\n\t\tvar delta = (IsClosed ? 1 : 0);\n\t\tvar polyCnt = pattern.length;\n\t\tvar pathCnt = path.length;\n\t\tvar result = new Array();\n\t\tif (IsSum)\n\t\t\tfor (var i = 0; i < pathCnt; i++)\n\t\t\t{\n\t\t\t\tvar p = new Array(polyCnt);\n\t\t\t\tfor (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t\t\t\t\tp[j] = new ClipperLib.FPoint2(path[i].X + ip.X, path[i].Y + ip.Y);\n\t\t\t\tresult.push(p);\n\t\t\t}\n\t\telse\n\t\t\tfor (var i = 0; i < pathCnt; i++)\n\t\t\t{\n\t\t\t\tvar p = new Array(polyCnt);\n\t\t\t\tfor (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t\t\t\t\tp[j] = new ClipperLib.FPoint2(path[i].X - ip.X, path[i].Y - ip.Y);\n\t\t\t\tresult.push(p);\n\t\t\t}\n\t\tvar quads = new Array();\n\t\tfor (var i = 0; i < pathCnt - 1 + delta; i++)\n\t\t\tfor (var j = 0; j < polyCnt; j++)\n\t\t\t{\n\t\t\t\tvar quad = new Array();\n\t\t\t\tquad.push(result[i % pathCnt][j % polyCnt]);\n\t\t\t\tquad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n\t\t\t\tquad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n\t\t\t\tquad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n\t\t\t\tif (!ClipperLib.Clipper.Orientation(quad))\n\t\t\t\t\tquad.reverse();\n\t\t\t\tquads.push(quad);\n\t\t\t}\n\t\treturn quads;\n\t};\n\n\tClipperLib.Clipper.MinkowskiSum = function (pattern, path_or_paths, pathIsClosed)\n\t{\n\t\tif (!(path_or_paths[0] instanceof Array))\n\t\t{\n\t\t\tvar path = path_or_paths;\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar paths = path_or_paths;\n\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t{\n\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tif (pathIsClosed)\n\t\t\t\t{\n\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn solution;\n\t\t}\n\t}\n\n\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t{\n\t\tvar outPath = new ClipperLib.Path();\n\t\tfor (var i = 0; i < path.length; i++)\n\t\t\toutPath.push(new ClipperLib.FPoint2(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\treturn outPath;\n\t}\n\n\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t{\n\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\tvar c = new ClipperLib.Clipper();\n\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\treturn paths;\n\t}\n\n\tClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n\t{\n\t\tvar result = new Array();\n\t\t//result.set_Capacity(polytree.get_Total());\n\t\tClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n\t{\n\t\tvar match = true;\n\t\tswitch (nt)\n\t\t{\n\t\t\tcase ClipperLib.Clipper.NodeType.ntOpen:\n\t\t\t\treturn;\n\t\t\tcase ClipperLib.Clipper.NodeType.ntClosed:\n\t\t\t\tmatch = !polynode.IsOpen;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tif (polynode.m_polygon.length > 0 && match)\n\t\t\tpaths.push(polynode.m_polygon);\n\t\tfor (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n\t\t\tClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n\t};\n\n\tClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n\t{\n\t\tvar result = new ClipperLib.Paths();\n\t\t//result.set_Capacity(polytree.ChildCount());\n\t\tfor (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n\t\t\tif (polytree.Childs()[i].IsOpen)\n\t\t\t\tresult.push(polytree.Childs()[i].m_polygon);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n\t{\n\t\tvar result = new ClipperLib.Paths();\n\t\t//result.set_Capacity(polytree.Total());\n\t\tClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n\t\treturn result;\n\t};\n\n\tInherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n\tClipperLib.Clipper.NodeType = {\n\t\tntAny: 0,\n\t\tntOpen: 1,\n\t\tntClosed: 2\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n\t{\n\t\tif (typeof (miterLimit) === \"undefined\") miterLimit = 2;\n\t\tif (typeof (arcTolerance) === \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t\tthis.m_destPolys = new ClipperLib.Paths();\n\t\tthis.m_srcPoly = new ClipperLib.Path();\n\t\tthis.m_destPoly = new ClipperLib.Path();\n\t\tthis.m_normals = new Array();\n\t\tthis.m_delta = 0;\n\t\tthis.m_sinA = 0;\n\t\tthis.m_sin = 0;\n\t\tthis.m_cos = 0;\n\t\tthis.m_miterLim = 0;\n\t\tthis.m_StepsPerRad = 0;\n\t\tthis.m_lowest = new ClipperLib.FPoint0();\n\t\tthis.m_polyNodes = new ClipperLib.PolyNode();\n\t\tthis.MiterLimit = miterLimit;\n\t\tthis.ArcTolerance = arcTolerance;\n\t\tthis.m_lowest.X = -1;\n\t};\n\n\tClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n\tClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n\tClipperLib.ClipperOffset.prototype.Clear = function ()\n\t{\n\t\tClipperLib.Clear(this.m_polyNodes.Childs());\n\t\tthis.m_lowest.X = -1;\n\t};\n\n\tClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n\t{\n\t\tvar highI = path.length - 1;\n\t\tif (highI < 0)\n\t\t\treturn;\n\t\tvar newNode = new ClipperLib.PolyNode();\n\t\tnewNode.m_jointype = joinType;\n\t\tnewNode.m_endtype = endType;\n\t\t//strip duplicate points from path and also get index to the lowest point ...\n\t\tif (endType === ClipperLib.EndType.etClosedLine || endType === ClipperLib.EndType.etClosedPolygon)\n\t\t\twhile (highI > 0 && ClipperLib.FPoint.op_Equality(path[0], path[highI]))\n\t\t\t\thighI--;\n\t\t//newNode.m_polygon.set_Capacity(highI + 1);\n\t\tnewNode.m_polygon.push(path[0]);\n\t\tvar j = 0,\n\t\t\tk = 0;\n\t\tfor (var i = 1; i <= highI; i++)\n\t\t\tif (ClipperLib.FPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n\t\t\t{\n\t\t\t\tj++;\n\t\t\t\tnewNode.m_polygon.push(path[i]);\n\t\t\t\tif (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y === newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n\t\t\t\t\tk = j;\n\t\t\t}\n\t\tif (endType === ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n\t\tthis.m_polyNodes.AddChild(newNode);\n\t\t//if this path's lowest pt is lower than all the others then update m_lowest\n\t\tif (endType !== ClipperLib.EndType.etClosedPolygon)\n\t\t\treturn;\n\t\tif (this.m_lowest.X < 0)\n\t\t\tthis.m_lowest = new ClipperLib.FPoint2(this.m_polyNodes.ChildCount() - 1, k);\n\t\telse\n\t\t{\n\t\t\tvar ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n\t\t\tif (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y === ip.Y && newNode.m_polygon[k].X < ip.X))\n\t\t\t\tthis.m_lowest = new ClipperLib.FPoint2(this.m_polyNodes.ChildCount() - 1, k);\n\t\t}\n\t};\n\n\tClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n\t{\n\t\tfor (var i = 0, ilen = paths.length; i < ilen; i++)\n\t\t\tthis.AddPath(paths[i], joinType, endType);\n\t};\n\n\tClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n\t{\n\t\t//fixup orientations of all closed paths if the orientation of the\n\t\t//closed path with the lowermost vertex is wrong ...\n\t\tif (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n\t\t{\n\t\t\tfor (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t\t\t{\n\t\t\t\tvar node = this.m_polyNodes.Childs()[i];\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedPolygon || (node.m_endtype === ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n\t\t\t\t\tnode.m_polygon.reverse();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t\t\t{\n\t\t\t\tvar node = this.m_polyNodes.Childs()[i];\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n\t\t\t\t\tnode.m_polygon.reverse();\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n\t{\n\t\tvar dx = (pt2.X - pt1.X);\n\t\tvar dy = (pt2.Y - pt1.Y);\n\t\tif ((dx === 0) && (dy === 0))\n\t\t\treturn new ClipperLib.FPoint2(0, 0);\n\t\tvar f = 1 / Math.sqrt(dx * dx + dy * dy);\n\t\tdx *= f;\n\t\tdy *= f;\n\t\treturn new ClipperLib.FPoint2(dy, -dx);\n\t};\n\n\tClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n\t{\n\t\tthis.m_destPolys = new Array();\n\t\tthis.m_delta = delta;\n\t\t//if Zero offset, just copy any CLOSED polygons to m_p and return ...\n\t\tif (ClipperLib.ClipperBase.near_zero(delta))\n\t\t{\n\t\t\t//this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n\t\t\tfor (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t\t\t{\n\t\t\t\tvar node = this.m_polyNodes.Childs()[i];\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n\t\t\t\t\tthis.m_destPolys.push(node.m_polygon);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t//see offset_triginometry3.svg in the documentation folder ...\n\t\tif (this.MiterLimit > 2)\n\t\t\tthis.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n\t\telse\n\t\t\tthis.m_miterLim = 0.5;\n\t\tvar y;\n\t\tif (this.ArcTolerance <= 0)\n\t\t\ty = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t\telse if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n\t\t\ty = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n\t\telse\n\t\t\ty = this.ArcTolerance;\n\t\t//see offset_triginometry2.svg in the documentation folder ...\n\t\tvar steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n\t\tthis.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n\t\tthis.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n\t\tthis.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n\t\tif (delta < 0)\n\t\t\tthis.m_sin = -this.m_sin;\n\t\t//this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n\t\tfor (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t\t{\n\t\t\tvar node = this.m_polyNodes.Childs()[i];\n\t\t\tthis.m_srcPoly = node.m_polygon;\n\t\t\tvar len = this.m_srcPoly.length;\n\t\t\tif (len === 0 || (delta <= 0 && (len < 3 || node.m_endtype !== ClipperLib.EndType.etClosedPolygon)))\n\t\t\t\tcontinue;\n\t\t\tthis.m_destPoly = new Array();\n\t\t\tif (len === 1)\n\t\t\t{\n\t\t\t\tif (node.m_jointype === ClipperLib.JoinType.jtRound)\n\t\t\t\t{\n\t\t\t\t\tvar X = 1,\n\t\t\t\t\t\tY = 0;\n\t\t\t\t\tfor (var j = 1; j <= steps; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[0].X + X * delta, this.m_srcPoly[0].Y + Y * delta));\n\t\t\t\t\t\tvar X2 = X;\n\t\t\t\t\t\tX = X * this.m_cos - this.m_sin * Y;\n\t\t\t\t\t\tY = X2 * this.m_sin + Y * this.m_cos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar X = -1,\n\t\t\t\t\t\tY = -1;\n\t\t\t\t\tfor (var j = 0; j < 4; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[0].X + X * delta, this.m_srcPoly[0].Y + Y * delta));\n\t\t\t\t\t\tif (X < 0)\n\t\t\t\t\t\t\tX = 1;\n\t\t\t\t\t\telse if (Y < 0)\n\t\t\t\t\t\t\tY = 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tX = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//build m_normals ...\n\t\t\tthis.m_normals.length = 0;\n\t\t\t//this.m_normals.set_Capacity(len);\n\t\t\tfor (var j = 0; j < len - 1; j++)\n\t\t\t\tthis.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedLine || node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n\t\t\t\tthis.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n\t\t\telse\n\t\t\t\tthis.m_normals.push(new ClipperLib.FPoint1(this.m_normals[len - 2]));\n\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n\t\t\t{\n\t\t\t\tvar k = len - 1;\n\t\t\t\tfor (var j = 0; j < len; j++)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t}\n\t\t\telse if (node.m_endtype === ClipperLib.EndType.etClosedLine)\n\t\t\t{\n\t\t\t\tvar k = len - 1;\n\t\t\t\tfor (var j = 0; j < len; j++)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t\tthis.m_destPoly = new Array();\n\t\t\t\t//re-build m_normals ...\n\t\t\t\tvar n = this.m_normals[len - 1];\n\t\t\t\tfor (var j = len - 1; j > 0; j--)\n\t\t\t\t\tthis.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t\t\t\tthis.m_normals[0] = new ClipperLib.FPoint2(-n.X, -n.Y);\n\t\t\t\tk = 0;\n\t\t\t\tfor (var j = len - 1; j >= 0; j--)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar k = 0;\n\t\t\t\tfor (var j = 1; j < len - 1; ++j)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tvar pt1;\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etOpenButt)\n\t\t\t\t{\n\t\t\t\t\tvar j = len - 1;\n\t\t\t\t\tpt1 = new ClipperLib.FPoint2(this.m_srcPoly[j].X + this.m_normals[j].X * delta, this.m_srcPoly[j].Y + this.m_normals[j].Y * delta);\n\t\t\t\t\tthis.m_destPoly.push(pt1);\n\t\t\t\t\tpt1 = new ClipperLib.FPoint2(this.m_srcPoly[j].X - this.m_normals[j].X * delta, this.m_srcPoly[j].Y - this.m_normals[j].Y * delta);\n\t\t\t\t\tthis.m_destPoly.push(pt1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar j = len - 1;\n\t\t\t\t\tk = len - 2;\n\t\t\t\t\tthis.m_sinA = 0;\n\t\t\t\t\tthis.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j].X, -this.m_normals[j].Y);\n\t\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etOpenSquare)\n\t\t\t\t\t\tthis.DoSquare(j, k);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.DoRound(j, k);\n\t\t\t\t}\n\t\t\t\t//re-build m_normals ...\n\t\t\t\tfor (var j = len - 1; j > 0; j--)\n\t\t\t\t\tthis.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t\t\t\tthis.m_normals[0] = new ClipperLib.FPoint2(-this.m_normals[1].X, -this.m_normals[1].Y);\n\t\t\t\tk = len - 1;\n\t\t\t\tfor (var j = k - 1; j > 0; --j)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etOpenButt)\n\t\t\t\t{\n\t\t\t\t\tpt1 = new ClipperLib.FPoint2(this.m_srcPoly[0].X - this.m_normals[0].X * delta, this.m_srcPoly[0].Y - this.m_normals[0].Y * delta);\n\t\t\t\t\tthis.m_destPoly.push(pt1);\n\t\t\t\t\tpt1 = new ClipperLib.FPoint2(this.m_srcPoly[0].X + this.m_normals[0].X * delta, this.m_srcPoly[0].Y + this.m_normals[0].Y * delta);\n\t\t\t\t\tthis.m_destPoly.push(pt1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tk = 1;\n\t\t\t\t\tthis.m_sinA = 0;\n\t\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etOpenSquare)\n\t\t\t\t\t\tthis.DoSquare(0, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.DoRound(0, 1);\n\t\t\t\t}\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.ClipperOffset.prototype.Execute = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\tispolytree = a[0] instanceof ClipperLib.PolyTree;\n\t\tif (!ispolytree) // function (solution, delta)\n\t\t{\n\t\t\tvar solution = a[0],\n\t\t\t\tdelta = a[1];\n\t\t\tClipperLib.Clear(solution);\n\t\t\tthis.FixOrientations();\n\t\t\tthis.DoOffset(delta);\n\t\t\t//now clean up 'corners' ...\n\t\t\tvar clpr = new ClipperLib.Clipper(0);\n\t\t\tclpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t\t\tif (delta > 0)\n\t\t\t{\n\t\t\t\tclpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t\t\t\tvar outer = new ClipperLib.Path();\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.left - 10, r.bottom + 10));\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.right + 10, r.bottom + 10));\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.right + 10, r.top - 10));\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.left - 10, r.top - 10));\n\t\t\t\tclpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tclpr.ReverseSolution = true;\n\t\t\t\tclpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t\t\t\tif (solution.length > 0)\n\t\t\t\t\tsolution.splice(0, 1);\n\t\t\t}\n\t\t\t//console.log(JSON.stringify(solution));\n\t\t}\n\t\telse // function (polytree, delta)\n\t\t{\n\t\t\tvar solution = a[0],\n\t\t\t\tdelta = a[1];\n\t\t\tsolution.Clear();\n\t\t\tthis.FixOrientations();\n\t\t\tthis.DoOffset(delta);\n\t\t\t//now clean up 'corners' ...\n\t\t\tvar clpr = new ClipperLib.Clipper(0);\n\t\t\tclpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t\t\tif (delta > 0)\n\t\t\t{\n\t\t\t\tclpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t\t\t\tvar outer = new ClipperLib.Path();\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.left - 10, r.bottom + 10));\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.right + 10, r.bottom + 10));\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.right + 10, r.top - 10));\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.left - 10, r.top - 10));\n\t\t\t\tclpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tclpr.ReverseSolution = true;\n\t\t\t\tclpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t\t\t\t//remove the outer PolyNode rectangle ...\n\t\t\t\tif (solution.ChildCount() === 1 && solution.Childs()[0].ChildCount() > 0)\n\t\t\t\t{\n\t\t\t\t\tvar outerNode = solution.Childs()[0];\n\t\t\t\t\t//solution.Childs.set_Capacity(outerNode.ChildCount);\n\t\t\t\t\tsolution.Childs()[0] = outerNode.Childs()[0];\n\t\t\t\t\tsolution.Childs()[0].m_Parent = solution;\n\t\t\t\t\tfor (var i = 1; i < outerNode.ChildCount(); i++)\n\t\t\t\t\t\tsolution.AddChild(outerNode.Childs()[i]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsolution.Clear();\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n\t{\n\t\t//cross product ...\n\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\n\t\tif (this.m_sinA === 0)\n\t\t{\n      return k;\n\t\t}\n\n/*\n\t\telse if (this.m_sinA < 0.00005 && this.m_sinA > -0.00005)\n{\n\t\t\tconsole.log(this.m_sinA);\n      return k;\n}\n*/\n/*\n\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t{\n\t\t\t//dot product ...\n\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t{\n\t\t\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta,\n\t\t\t\t\tthis.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta));\n\t\t\t\treturn k;\n\t\t\t}\n\t\t\t//else angle ==> 180 degrees\n\t\t}\n*/\n\t\telse if (this.m_sinA > 1)\n\t\t\tthis.m_sinA = 1.0;\n\t\telse if (this.m_sinA < -1)\n\t\t\tthis.m_sinA = -1.0;\n\t\tif (this.m_sinA * this.m_delta < 0)\n\t\t{\n\t\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta,\n\t\t\t\tthis.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta));\n\t\t\tthis.m_destPoly.push(new ClipperLib.FPoint1(this.m_srcPoly[j]));\n\t\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta,\n\t\t\t\tthis.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta));\n\t\t}\n\t\telse\n\t\t\tswitch (jointype)\n\t\t\t{\n\t\t\tcase ClipperLib.JoinType.jtMiter:\n\t\t\t\t{\n\t\t\t\t\tvar r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\t\t\tif (r >= this.m_miterLim)\n\t\t\t\t\t\tthis.DoMiter(j, k, r);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.DoSquare(j, k);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase ClipperLib.JoinType.jtSquare:\n\t\t\t\tthis.DoSquare(j, k);\n\t\t\t\tbreak;\n\t\t\tcase ClipperLib.JoinType.jtRound:\n\t\t\t\tthis.DoRound(j, k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tk = j;\n\t\treturn k;\n\t};\n\n\tClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n\t{\n\t\tvar dx = Math.tan(Math.atan2(this.m_sinA,\n\t\t\tthis.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(\n\t\t\tthis.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx),\n\t\t\tthis.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx)));\n\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(\n\t\t\tthis.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx),\n\t\t\tthis.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx)));\n\t};\n\n\tClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n\t{\n\t\tvar q = this.m_delta / r;\n\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(\n\t\t\tthis.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q,\n\t\t\tthis.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q));\n\t};\n\n\tClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n\t{\n\t\tvar a = Math.atan2(this.m_sinA,\n\t\t\tthis.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\n\t\tvar steps = Math.max(Math.round(this.m_StepsPerRad * Math.abs(a)), 1);\n\n\t\tvar X = this.m_normals[k].X,\n\t\t\tY = this.m_normals[k].Y,\n\t\t\tX2;\n\t\tfor (var i = 0; i < steps; ++i)\n\t\t{\n\t\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(\n\t\t\t\tthis.m_srcPoly[j].X + X * this.m_delta,\n\t\t\t\tthis.m_srcPoly[j].Y + Y * this.m_delta));\n\t\t\tX2 = X;\n\t\t\tX = X * this.m_cos - this.m_sin * Y;\n\t\t\tY = X2 * this.m_sin + Y * this.m_cos;\n\t\t}\n\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(\n\t\t\tthis.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta,\n\t\t\tthis.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta));\n\t};\n\n\tClipperLib.Error = function (message)\n\t{\n\t\ttry\n\t\t{\n\t\t\tthrow new Error(message);\n\t\t}\n\t\tcatch (err)\n\t\t{\n\t\t\talert(err.message);\n\t\t}\n\t};\n\n\t// ---------------------------------------------\n\n\t// JS extension by Timo 2013\n\tClipperLib.JS = {};\n\n\tClipperLib.JS.AreaOfPolygon = function (poly)\n\t{\n\t\treturn ClipperLib.Clipper.Area(poly);\n\t};\n\n\tClipperLib.JS.AreaOfPolygons = function (poly)\n\t{\n\t\tvar area = 0;\n\t\tfor (var i = 0; i < poly.length; i++)\n\t\t{\n\t\t\tarea += ClipperLib.Clipper.Area(poly[i]);\n\t\t}\n\t\treturn area;\n\t};\n\n\tClipperLib.JS.BoundsOfPath = function (path)\n\t{\n\t\treturn ClipperLib.JS.BoundsOfPaths([path]);\n\t};\n\n\tClipperLib.JS.BoundsOfPaths = function (paths)\n\t{\n\t\tvar bounds = ClipperLib.Clipper.GetBounds(paths);\n\t\treturn bounds;\n\t};\n\n\t// Clean() joins vertices that are too near each other\n\t// and causes distortion to offsetted polygons without cleaning\n\tClipperLib.JS.Clean = function (polygon, delta)\n\t{\n\t\tif (!(polygon instanceof Array)) return [];\n\t\tvar isPolygons = polygon[0] instanceof Array;\n\t\tvar polygon = ClipperLib.JS.Clone(polygon);\n\t\tif (typeof delta !== \"number\" || delta === null)\n\t\t{\n\t\t\tClipperLib.Error(\"Delta is not a number in Clean().\");\n\t\t\treturn polygon;\n\t\t}\n\t\tif (polygon.length === 0 || (polygon.length === 1 && polygon[0].length === 0) || delta < 0) return polygon;\n\t\tif (!isPolygons) polygon = [polygon];\n\t\tvar k_length = polygon.length;\n\t\tvar len, poly, result, d, p, j, i;\n\t\tvar results = [];\n\t\tfor (var k = 0; k < k_length; k++)\n\t\t{\n\t\t\tpoly = polygon[k];\n\t\t\tlen = poly.length;\n\t\t\tif (len === 0) continue;\n\t\t\telse if (len < 3)\n\t\t\t{\n\t\t\t\tresult = poly;\n\t\t\t\tresults.push(result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult = poly;\n\t\t\td = delta * delta;\n\t\t\t//d = Math.floor(c_delta * c_delta);\n\t\t\tp = poly[0];\n\t\t\tj = 1;\n\t\t\tfor (i = 1; i < len; i++)\n\t\t\t{\n\t\t\t\tif ((poly[i].X - p.X) * (poly[i].X - p.X) +\n\t\t\t\t\t(poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n\t\t\t\t\tcontinue;\n\t\t\t\tresult[j] = poly[i];\n\t\t\t\tp = poly[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tp = poly[j - 1];\n\t\t\tif ((poly[0].X - p.X) * (poly[0].X - p.X) +\n\t\t\t\t(poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n\t\t\t\tj--;\n\t\t\tif (j < len)\n\t\t\t\tresult.splice(j, len - j);\n\t\t\tif (result.length) results.push(result);\n\t\t}\n\t\tif (!isPolygons && results.length) results = results[0];\n\t\telse if (!isPolygons && results.length === 0) results = [];\n\t\telse if (isPolygons && results.length === 0) results = [\n\t\t\t[]\n\t\t];\n\t\treturn results;\n\t}\n\t// Make deep copy of Polygons or Polygon\n\t// so that also FPoint objects are cloned and not only referenced\n\t// This should be the fastest way\n\tClipperLib.JS.Clone = function (polygon)\n\t{\n\t\tif (!(polygon instanceof Array)) return [];\n\t\tif (polygon.length === 0) return [];\n\t\telse if (polygon.length === 1 && polygon[0].length === 0) return [\n\t\t\t[]\n\t\t];\n\t\tvar isPolygons = polygon[0] instanceof Array;\n\t\tif (!isPolygons) polygon = [polygon];\n\t\tvar len = polygon.length,\n\t\t\tplen, i, j, result;\n\t\tvar results = new Array(len);\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\tplen = polygon[i].length;\n\t\t\tresult = new Array(plen);\n\t\t\tfor (j = 0; j < plen; j++)\n\t\t\t{\n\t\t\t\tresult[j] = {\n\t\t\t\t\tX: polygon[i][j].X,\n\t\t\t\t\tY: polygon[i][j].Y\n\t\t\t\t};\n\n\t\t\t}\n\t\t\tresults[i] = result;\n\t\t}\n\t\tif (!isPolygons) results = results[0];\n\t\treturn results;\n\t};\n\n\t// Removes points that doesn't affect much to the visual appearance.\n\t// If middle point is at or under certain distance (tolerance) of the line segment between\n\t// start and end point, the middle point is removed.\n\tClipperLib.JS.Lighten = function (polygon, tolerance)\n\t{\n\t\tif (!(polygon instanceof Array)) return [];\n\t\tif (typeof tolerance !== \"number\" || tolerance === null)\n\t\t{\n\t\t\tClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n\t\t\treturn ClipperLib.JS.Clone(polygon);\n\t\t}\n\t\tif (polygon.length === 0 || (polygon.length === 1 && polygon[0].length === 0) || tolerance < 0)\n\t\t{\n\t\t\treturn ClipperLib.JS.Clone(polygon);\n\t\t}\n\t\tvar isPolygons = polygon[0] instanceof Array;\n\t\tif (!isPolygons) polygon = [polygon];\n\t\tvar i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n\t\tvar bxax, byay, l, ax, ay;\n\t\tvar len = polygon.length;\n\t\tvar toleranceSq = tolerance * tolerance;\n\t\tvar results = [];\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\tpoly = polygon[i];\n\t\t\tplen = poly.length;\n\t\t\tif (plen === 0) continue;\n\t\t\tfor (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n\t\t\t{\n\t\t\t\tpoly2 = [];\n\t\t\t\tplen = poly.length;\n\t\t\t\t// the first have to added to the end, if first and last are not the same\n\t\t\t\t// this way we ensure that also the actual last point can be removed if needed\n\t\t\t\tif (poly[plen - 1].X !== poly[0].X || poly[plen - 1].Y !== poly[0].Y)\n\t\t\t\t{\n\t\t\t\t\taddlast = 1;\n\t\t\t\t\tpoly.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tX: poly[0].X,\n\t\t\t\t\t\tY: poly[0].Y\n\t\t\t\t\t});\n\t\t\t\t\tplen = poly.length;\n\t\t\t\t}\n\t\t\t\telse addlast = 0;\n\t\t\t\trem = []; // Indexes of removed points\n\t\t\t\tfor (j = 0; j < plen - 2; j++)\n\t\t\t\t{\n\t\t\t\t\tA = poly[j]; // Start point of line segment\n\t\t\t\t\tP = poly[j + 1]; // Middle point. This is the one to be removed.\n\t\t\t\t\tB = poly[j + 2]; // End point of line segment\n\t\t\t\t\tax = A.X;\n\t\t\t\t\tay = A.Y;\n\t\t\t\t\tbxax = B.X - ax;\n\t\t\t\t\tbyay = B.Y - ay;\n\t\t\t\t\tif (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n\t\t\t\t\t{\n\t\t\t\t\t\tl = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n\t\t\t\t\t\tif (l > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tax = B.X;\n\t\t\t\t\t\t\tay = B.Y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (l > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tax += bxax * l;\n\t\t\t\t\t\t\tay += byay * l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbxax = P.X - ax;\n\t\t\t\t\tbyay = P.Y - ay;\n\t\t\t\t\td = bxax * bxax + byay * byay;\n\t\t\t\t\tif (d <= toleranceSq)\n\t\t\t\t\t{\n\t\t\t\t\t\trem[j + 1] = 1;\n\t\t\t\t\t\tj++; // when removed, transfer the pointer to the next one\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// add all unremoved points to poly2\n\t\t\t\tpoly2.push(\n\t\t\t\t{\n\t\t\t\t\tX: poly[0].X,\n\t\t\t\t\tY: poly[0].Y\n\t\t\t\t});\n\t\t\t\tfor (j = 1; j < plen - 1; j++)\n\t\t\t\t\tif (!rem[j]) poly2.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tX: poly[j].X,\n\t\t\t\t\t\tY: poly[j].Y\n\t\t\t\t\t});\n\t\t\t\tpoly2.push(\n\t\t\t\t{\n\t\t\t\t\tX: poly[plen - 1].X,\n\t\t\t\t\tY: poly[plen - 1].Y\n\t\t\t\t});\n\t\t\t\t// if the first point was added to the end, remove it\n\t\t\t\tif (addlast) poly.pop();\n\t\t\t\t// break, if there was not anymore removed points\n\t\t\t\tif (!rem.length) break;\n\t\t\t\t// else continue looping using poly2, to check if there are points to remove\n\t\t\t\telse poly = poly2;\n\t\t\t}\n\t\t\tplen = poly2.length;\n\t\t\t// remove duplicate from end, if needed\n\t\t\tif (poly2[plen - 1].X === poly2[0].X && poly2[plen - 1].Y === poly2[0].Y)\n\t\t\t{\n\t\t\t\tpoly2.pop();\n\t\t\t}\n\t\t\tif (poly2.length > 2) // to avoid two-point-polygons\n\t\t\t\tresults.push(poly2);\n\t\t}\n\t\tif (!isPolygons)\n\t\t{\n\t\t\tresults = results[0];\n\t\t}\n\t\tif (typeof (results) === \"undefined\")\n\t\t{\n\t\t\tresults = [];\n\t\t}\n\t\treturn results;\n\t}\n\n\tClipperLib.JS.PerimeterOfPath = function (path, closed)\n\t{\n\t\tif (typeof (path) === \"undefined\") return 0;\n\t\tvar sqrt = Math.sqrt;\n\t\tvar perimeter = 0.0;\n\t\tvar p1, p2, p1x = 0.0,\n\t\t\tp1y = 0.0,\n\t\t\tp2x = 0.0,\n\t\t\tp2y = 0.0;\n\t\tvar j = path.length;\n\t\tif (j < 2) return 0;\n\t\tif (closed)\n\t\t{\n\t\t\tpath[j] = path[0];\n\t\t\tj++;\n\t\t}\n\t\twhile (--j)\n\t\t{\n\t\t\tp1 = path[j];\n\t\t\tp1x = p1.X;\n\t\t\tp1y = p1.Y;\n\t\t\tp2 = path[j - 1];\n\t\t\tp2x = p2.X;\n\t\t\tp2y = p2.Y;\n\t\t\tperimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n\t\t}\n\t\tif (closed) path.pop();\n\t\treturn perimeter;\n\t};\n\n\tClipperLib.JS.PerimeterOfPaths = function (paths, closed)\n\t{\n\t\tvar perimeter = 0;\n\t\tfor (var i = 0; i < paths.length; i++)\n\t\t{\n\t\t\tperimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed);\n\t\t}\n\t\treturn perimeter;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.ExPolygons = function ()\n\t{\n\t\treturn [];\n\t}\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.ExPolygon = function ()\n\t{\n\t\tthis.outer = null;\n\t\tthis.holes = null;\n\t};\n\n\tClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n\t{\n\t\tvar ep = new ClipperLib.ExPolygon();\n\t\tep.outer = polynode.Contour();\n\t\tvar childs = polynode.Childs();\n\t\tvar ilen = childs.length;\n\t\tep.holes = new Array(ilen);\n\t\tvar node, n, i, j, childs2, jlen;\n\t\tfor (i = 0; i < ilen; i++)\n\t\t{\n\t\t\tnode = childs[i];\n\t\t\tep.holes[i] = node.Contour();\n\t\t\t//Add outer polygons contained by (nested within) holes ...\n\t\t\tfor (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n\t\t\t{\n\t\t\t\tn = childs2[j];\n\t\t\t\tClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n\t\t\t}\n\t\t}\n\t\texpolygons.push(ep);\n\t};\n\n\tClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n\t{\n\t\tvar a, i, alen, ilen;\n\t\tvar paths = new ClipperLib.Paths();\n\t\tfor (a = 0, alen = expolygons.length; a < alen; a++)\n\t\t{\n\t\t\tpaths.push(expolygons[a].outer);\n\t\t\tfor (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n\t\t\t{\n\t\t\t\tpaths.push(expolygons[a].holes[i]);\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\tClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n\t{\n\t\tvar expolygons = new ClipperLib.ExPolygons();\n\t\tvar node, i, childs, ilen;\n\t\tfor (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n\t\t{\n\t\t\tnode = childs[i];\n\t\t\tClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n\t\t}\n\t\treturn expolygons;\n\t};\n\n\tmodule.exports = ClipperLib;\n"],"names":["ClipperLib","version","use_lines","use_xyz","Inherit","ce","ce2","p","Object","getOwnPropertyNames","prototype","$baseCtor","props","i","length","getOwnPropertyDescriptor","defineProperty","Path","push","Array","Paths","PolyNode","this","m_Parent","m_polygon","m_Index","m_jointype","m_endtype","m_Childs","IsOpen","IsHoleNode","result","node","ChildCount","Contour","AddChild","Child","cnt","GetNext","GetNextSiblingUp","Childs","Parent","IsHole","PolyTree","m_AllPolys","call","Clear","ilen","GetFirst","Total","a","PI","PI2","FPoint","arguments","alen","X","Y","Z","dp","pt","op_Equality","b","op_Inequality","FPoint0","FPoint1","FPoint1dp","FPoint2","x","y","z","FRect","left","top","right","bottom","ir","FRect0","FRect1","FRect4","l","t","r","ClipType","ctIntersection","ctUnion","ctDifference","ctXor","PolyType","ptSubject","ptClip","PolyFillType","pftEvenOdd","pftNonZero","pftPositive","pftNegative","JoinType","jtSquare","jtRound","jtMiter","EndType","etOpenSquare","etOpenRound","etOpenButt","etClosedLine","etClosedPolygon","EdgeSide","esLeft","esRight","Direction","dRightToLeft","dLeftToRight","TEdge","Bot","Curr","Top","Delta","Dx","PolyTyp","Side","WindDelta","WindCnt","WindCnt2","OutIdx","Next","Prev","NextInLML","NextInAEL","PrevInAEL","NextInSEL","PrevInSEL","IntersectNode","Edge1","Edge2","Pt","MyIntersectNodeSort","Compare","node1","node2","LocalMinima","LeftBound","RightBound","Scanbeam","Maxima","OutRec","Idx","FirstLeft","Pts","BottomPt","OutPt","Join","OutPt1","OutPt2","OffPt","ClipperBase","m_MinimaList","m_CurrentLM","m_edges","m_HasOpenPaths","PreserveCollinear","m_Scanbeam","m_PolyOuts","m_ActiveEdges","horizontal","Skip","Unassigned","tolerance","maxValue","Math","sqrt","Number","MAX_VALUE","minValue","MIN_VALUE","near_zero","val","IsHorizontal","e","PointIsVertex","pp","pp2","PointOnLineSegment","linePt1","linePt2","PointOnPolygon","SlopesEqual","e1","e2","pt1","pt2","pt3","pt4","SlopesEqual3","SlopesEqual4","SlopesEqual5","DisposeLocalMinimaList","j","jlen","tmpLm","RangeTest","Error","InitEdge","eNext","ePrev","InitEdge2","polyType","SetDx","FindNextLocMin","E","E2","ProcessBound","LeftBoundIsForward","EStart","Horz","Result","locMin","InsertLocalMinima","ReverseHorizontal","AddPath","pg","Closed","highI","edges","IsFlat","leftBoundIsForward","eStart","eLoopStop","Pt2IsBetweenPt1AndPt3","RemoveEdge","EMin","AddPaths","ppg","closed","newLm","PopLocalMinima","current","v","tmp","Reset","lm","InsertScanbeam","newSb","sb2","newSb1","PopScanbeam","LocalMinimaPending","CreateOutRec","DisposeOutRec","index","outRec","UpdateEdgeIntoAEL","AelPrev","AelNext","SwapPositionsInAEL","edge1","edge2","next","prev","next1","prev1","next2","prev2","DeleteFromAEL","Clipper","InitOptions","m_ClipType","m_Maxima","m_SortedEdges","m_IntersectList","m_IntersectNodeComparer","m_ExecuteLocked","m_ClipFillType","m_SubjFillType","m_Joins","m_GhostJoins","m_UsingPolyTree","ReverseSolution","StrictlySimple","ZFillFunction","ioReverseSolution","ioStrictlySimple","ioPreserveCollinear","DisposeAllPolyPts","InsertMaxima","newMax","m","Execute","ispolytree","clipType","solution","subjFillType","clipFillType","succeeded","ExecuteInternal","BuildResult","polytree","BuildResult2","FixHoleLinkage","orfl","botY","topY","InsertLocalMinimaIntoAEL","ProcessHorizontals","ProcessIntersections","ProcessEdgesAtTopOfScanbeam","Area$1","ReversePolyPtLinks","JoinCommonEdges","FixupOutPolyline","FixupOutPolygon","DoSimplePolygons","AddJoin","Op1","Op2","AddGhostJoin","Op","SetZ","lb","rb","InsertEdgeIntoAEL","SetWindingCount","IsContributing","AddOutPt","AddLocalMinPoly","AddEdgeToSEL","HorzSegmentsOverlap","IntersectEdges","edge","startEdge","E2InsertsBeforeE1","TopX","IsEvenOddFillType","IsEvenOddAltFillType","pft","pft2","abs","Inside","PopEdgeFromSEL","oldE","CopyAELToSEL","SwapPositionsInSEL","AddLocalMaxPoly","AppendPolygon","prevE","xPrev","xE","outPt","newOp","SetHoleState","op","ToFront","GetLastOutPt","SwapPoints","Value","seg1a","seg1b","seg2a","seg2b","eTmp","GetDx","FirstIsBottomPt","btmPt1","btmPt2","dx1p","dx1n","dx2p","dx2n","max","min","Area","GetBottomPt","dups","GetLowermostRec","outRec1","outRec2","bPt1","bPt2","OutRec1RightOfOutRec2","GetOutRec","idx","outrec","holeStateRec","p1_lft","p1_rt","p2_lft","p2_rt","OKIdx","ObsoleteIdx","pp1","SwapSides","side","SwapPolyIndexes","outIdx","e1Contributing","e2Contributing","oldE1WindCnt","e1FillType","e2FillType","e1FillType2","e2FillType2","e1Wc","e2Wc","e1Wc2","e2Wc2","DeleteFromSEL","SelPrev","SelNext","horzEdge","ProcessHorizontal","GetHorzDirection","HorzEdge","$var","Left","Right","Dir","dir","horzLeft","horzRight","eLastHorz","eMaxPair","GetMaximaPair","currMax","op1","IsLastHorz","GetNextInAEL","eNextHorz","op2","IsMinima","IsMaxima","IsIntermediate","GetMaximaPairEx","BuildIntersectList","FixupIntersectionOrder","ProcessIntersectList","$$e2","isModified","IntersectPoint","newNode","EdgesAdjacent","inode","IntersectNodeSort","sort","iNode","currentY","ip","b1","b2","q","IsMaximaEdge","DoMaxima","ePrev2","ReversePaths","polys","len","reverse","Orientation","poly","PointCount","pts","polyg","pn","lastPP","tmpPP","lastOK","preserveCol","DupOutPt","InsertAfter","GetOverlap","a1","a2","$val","JoinHorz","op1b","op2b","DiscardLeft","Dir1","Dir2","JoinPoints","isHorizontal","reverse1","DiscardLeftSide","Reverse1","Reverse2","GetBounds","paths","GetBounds2","ops","opStart","PointInPolygon","path","ipNext","d","startOp","ptx","pty","poly0x","poly0y","poly1x","poly1y","Poly2ContainsPoly1","outPt1","outPt2","res","FixupFirstLefts1","OldOutRec","NewOutRec","firstLeft","ParseFirstLeft","FixupFirstLefts2","innerOutRec","outerOutRec","FixupFirstLefts3","join","UpdateOutPtIdxs","op3","op4","outrec2","isArray","opFirst","SimplifyPolygon","fillType","c","SimplifyPolygons","DistanceSqrd","dx","dy","DistanceFromLineSqrd","ln1","ln2","A","B","C","SlopesNearCollinear","distSqrd","PointsAreClose","ExcludeOp","CleanPolygon","distance","outPts","CleanPolygons","Minkowski","pattern","IsSum","IsClosed","delta","polyCnt","pathCnt","quads","quad","MinkowskiSum","path_or_paths","pathIsClosed","TranslatePath","outPath","MinkowskiDiff","poly1","poly2","PolyTreeToPaths","AddPolyNodeToPaths","NodeType","ntAny","polynode","nt","match","ntOpen","ntClosed","$i3","$t3","$l3","OpenPathsFromPolyTree","ClosedPathsFromPolyTree","ClipperOffset","miterLimit","arcTolerance","def_arc_tolerance","m_destPolys","m_srcPoly","m_destPoly","m_normals","m_delta","m_sinA","m_sin","m_cos","m_miterLim","m_StepsPerRad","m_lowest","m_polyNodes","MiterLimit","ArcTolerance","two_pi","joinType","endType","k","FixOrientations","GetUnitNormal","f","DoOffset","steps","acos","sin","cos","OffsetPoint","n","DoSquare","DoRound","X2","clpr","outer","outerNode","splice","jointype","DoMiter","tan","atan2","round","message","err","alert","JS","AreaOfPolygon","AreaOfPolygons","area","BoundsOfPath","BoundsOfPaths","Clean","polygon","isPolygons","Clone","k_length","results","plen","Lighten","P","rem","addlast","bxax","byay","ax","ay","toleranceSq","pop","PerimeterOfPath","p1","p2","perimeter","p1x","p1y","p2x","p2y","PerimeterOfPaths","ExPolygons","ExPolygon","holes","AddOuterPolyNodeToExPolygons","expolygons","ep","childs2","childs","ExPolygonsToPaths","PolyTreeToExPolygons","module","exports"],"mappings":"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"}